<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Author Analysis (Experimental) - SBOM Play</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <link rel="stylesheet" href="css/style.css?v=0.0.3">
    <link rel="stylesheet" href="css/themes.css?v=0.0.3">
    <script src="js/theme-manager.js?v=0.0.3&cb=1732460000000"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="index.html">
                <i class="fas fa-cube me-2"></i>SBOM Play
            </a>
            <div class="navbar-nav ms-auto">
                <a class="nav-link" href="index.html">Home</a>
                <a class="nav-link" href="licenses.html">License</a>
                <a class="nav-link" href="vuln.html">Vulns</a>
                <a class="nav-link" href="audit.html">Audit</a>
                <a class="nav-link" href="deps.html">Deps</a>
                <a class="nav-link" href="repos.html">Repos</a>
                <a class="nav-link active" href="authors.html">Authors</a>
                <a class="nav-link" href="about.html">About</a>
                <a class="nav-link" href="settings.html">Settings</a>
                <button class="btn btn-outline-secondary btn-sm ms-2 theme-toggle" title="Toggle theme">
                    <i class="fas fa-sun"></i>
                </button>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="alert alert-warning alert-dismissible fade show" role="alert">
            <i class="fas fa-flask me-2"></i>
            <strong>Experimental Feature:</strong> This page is currently experimental and may have limitations or incomplete data.
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>
        
        <!-- Header -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h1><i class="fas fa-users me-2"></i>Author Analysis <span class="badge bg-warning text-dark">Experimental</span></h1>
                        <p class="text-muted">View package authors and maintainers from third-party dependencies ranked by contribution across your supply chain</p>
                    </div>
                    <div>
                        <a href="index.html" class="btn btn-outline-primary">
                            <i class="fas fa-arrow-left me-2"></i>Back to Analysis
                        </a>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="alert alert-info alert-dismissible fade show mb-4" role="alert">
            <i class="fas fa-info-circle me-2"></i>
            <strong>Important:</strong> The authors, contributors, and maintainers listed here are from 
            <strong>third-party packages and dependencies</strong> used by your repositories, not the 
            repository authors themselves. This shows who maintains the external libraries your project depends on.
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>
        
        <!-- View Selector -->
        <div class="card mb-4">
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <label class="form-label">Select Analysis</label>
                        <select class="form-select" id="analysisSelector">
                            <option value="combined">Combined (All Scans)</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Filter by Ecosystem</label>
                        <select class="form-select" id="ecosystemFilter">
                            <option value="all">All Ecosystems</option>
                            <option value="npm">NPM</option>
                            <option value="pypi">PyPI</option>
                            <option value="maven">Maven</option>
                            <option value="cargo">Cargo</option>
                            <option value="go">Go</option>
                            <option value="nuget">NuGet</option>
                            <option value="composer">Composer</option>
                            <option value="rubygems">RubyGems</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Filter by Location</label>
                        <select class="form-select" id="locationFilter">
                            <option value="all">All Locations</option>
                        </select>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-md-6">
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="checkbox" id="fundingFilter" value="funding">
                            <label class="form-check-label" for="fundingFilter">
                                <i class="fas fa-heart me-1 text-danger"></i>Show only authors looking for sponsorship
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="sanctionsFilter" value="sanctions">
                            <label class="form-check-label" for="sanctionsFilter">
                                <i class="fas fa-ban me-1 text-danger"></i>Show only authors from sanctioned countries
                            </label>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label"><i class="fas fa-list-ol me-1"></i>Display Limit</label>
                        <div class="btn-group w-100" role="group" aria-label="Author display limit">
                            <input type="radio" class="btn-check" name="displayLimit" id="displayLimit25" value="25" checked>
                            <label class="btn btn-outline-primary" for="displayLimit25">
                                <i class="fas fa-filter me-1"></i>Top 25 Authors
                            </label>
                            
                            <input type="radio" class="btn-check" name="displayLimit" id="displayLimitAll" value="all">
                            <label class="btn btn-outline-primary" for="displayLimitAll">
                                <i class="fas fa-list me-1"></i>All Authors
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Author Map -->
        <div class="card mb-4 author-map-card" id="authorMapCard">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5><i class="fas fa-globe me-2"></i>Author Locations Map</h5>
                <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleMapBtn">
                    <i class="fas fa-eye-slash me-1"></i>Hide Map
                </button>
            </div>
            <div class="card-body">
                <div class="alert alert-warning alert-dismissible fade show mb-3" role="alert">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    <strong>Location Data Disclaimer:</strong> Author locations shown on this map are based on voluntarily provided information from authors themselves (typically from their GitHub profiles, package registry profiles, or other public sources). This information may be incomplete, outdated, or inaccurate. Locations are geocoded automatically and may not reflect the actual current location of authors.
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
                <div id="authorMap" class="author-map"></div>
            </div>
        </div>

        <!-- Author List -->
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5><i class="fas fa-list me-2"></i>Authors by Contribution</h5>
                <button type="button" class="btn btn-sm btn-outline-primary" id="showMapBtn">
                    <i class="fas fa-map me-1"></i>Show Map
                </button>
            </div>
            <div class="card-body">
                <div id="authorContent">
                    <p class="text-muted text-center">Loading author data...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Package List Modal -->
    <div class="modal fade" id="packageModal" tabindex="-1" aria-labelledby="packageModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="packageModalLabel">Packages</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="packageModalContent"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Author Details Modal -->
    <div class="modal fade" id="authorDetailsModal" tabindex="-1" aria-labelledby="authorDetailsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="authorDetailsModalLabel">Author Details</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="authorDetailsContent"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="js/indexeddb-manager.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/utils.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/registry-utils.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/version-utils.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/ecosystem-utils.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/cache-manager.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/storage-manager.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/location-service.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/sanctions-service.js?v=0.0.3&cb=1732460000000"></script>
    <script src="js/author-service.js?v=0.0.3&cb=1732460000000"></script>
    <script type="module">
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üë• Authors Page - Initializing...');
            
            // Store authors globally for event handlers (must be at top of scope)
            let currentAuthors = [];
            let filteredAuthors = [];
            let allFilteredAuthors = []; // All authors after filters (including single-package-single-repo) - used for map
            let displayLimit = localStorage.getItem('authorsDisplayLimit') || '25'; // '25' or 'all'
            let authorMap = null; // Leaflet map instance
            let locationService = null; // LocationService instance
            
            // Sanitize search input to prevent injection attacks
            function sanitizeSearchInput(input) {
                if (!input || typeof input !== 'string') return '';
                // Remove any potentially dangerous characters, limit length
                return input
                    .trim()
                    .substring(0, 200) // Limit length
                    .replace(/[<>\"'&]/g, ''); // Remove HTML/script injection chars
            }
            
            // Create AuthorService instance for secure URL validation
            const authorService = new AuthorService();
            
            // Initialize LocationService
            if (window.LocationService) {
                locationService = new LocationService();
            }
            
            // Initialize SanctionsService
            let sanctionsService = null;
            if (window.SanctionsService) {
                sanctionsService = new SanctionsService();
                window.sanctionsService = sanctionsService; // Make globally available
            }
            
            /**
             * Enrich author with country code(s) from geocoded location cache or geocode if needed
             * Handles multiple locations separated by |, \, or /
             * @param {Object} author - Author object
             * @returns {Promise<Object>} - Author with enriched country code(s)
             */
            async function enrichAuthorWithCountryCode(author) {
                // If already has country codes, return as-is (already persisted in database)
                if (author.metadata?.countryCode || author.metadata?.countryCodes) {
                    return author; // Skip - already enriched and persisted
                }
                
                // If no location, can't get country code
                const location = author.metadata?.location || author.metadata?.company || null;
                if (!location || !locationService) {
                    return author;
                }
                
                try {
                    // Parse multiple locations (handles |, \, / separators)
                    const locationParts = locationService.parseMultipleLocations(location);
                    const countryCodes = new Set();
                    const countries = [];
                    
                    for (const locationPart of locationParts) {
                        // Normalize each location part
                        const normalizedLocation = locationService.normalizeLocationString(locationPart);
                        if (!normalizedLocation) {
                            continue; // Skip invalid locations
                        }
                        
                        // Load from cache only (locations are already geocoded during analysis phase)
                        // Use getFromCache() to prevent API calls - only loads from cache
                        const geocoded = await locationService.getFromCache(normalizedLocation);
                        
                        if (geocoded && geocoded.countryCode) {
                            countryCodes.add(geocoded.countryCode);
                            if (geocoded.country && !countries.includes(geocoded.country)) {
                                countries.push(geocoded.country);
                            }
                        }
                    }
                    
                    if (countryCodes.size > 0) {
                        // Update author metadata with country code(s)
                        if (!author.metadata) {
                            author.metadata = {};
                        }
                        
                        // Store as array if multiple countries, single string if one country
                        const countryCodesArray = Array.from(countryCodes);
                        if (countryCodesArray.length === 1) {
                            author.metadata.countryCode = countryCodesArray[0];
                            author.metadata.country = countries[0] || null;
                        } else {
                            // Multiple countries - store as array
                            author.metadata.countryCodes = countryCodesArray;
                            author.metadata.countryCode = countryCodesArray[0]; // Primary country (first one)
                            author.metadata.countries = countries;
                            author.metadata.country = countries.join(', ') || null;
                        }
                        
                        // Save updated author entity to IndexedDB (persists permanently)
                        if (window.cacheManager && author.authorKey) {
                            try {
                                const authorEntity = await window.cacheManager.getAuthorEntity(author.authorKey);
                                if (authorEntity) {
                                    authorEntity.metadata = {
                                        ...authorEntity.metadata,
                                        ...author.metadata
                                    };
                                    await window.cacheManager.saveAuthorEntity(author.authorKey, authorEntity);
                                    if (countryCodesArray.length === 1) {
                                        console.log(`üíæ Saved country code ${countryCodesArray[0]} for author ${author.authorKey} to IndexedDB`);
                                    } else {
                                        console.log(`üíæ Saved ${countryCodesArray.length} country codes (${countryCodesArray.join(', ')}) for author ${author.authorKey} to IndexedDB`);
                                    }
                                } else {
                                    console.warn(`‚ö†Ô∏è Could not find author entity ${author.authorKey} to save country code`);
                                }
                            } catch (error) {
                                console.error(`‚ùå Failed to save country code for ${author.authorKey}:`, error.message);
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è Cannot save country code: cacheManager=${!!window.cacheManager}, authorKey=${!!author.authorKey}`);
                        }
                    }
                } catch (error) {
                    console.debug(`Could not enrich country code for author ${author.author}:`, error.message);
                }
                
                return author;
            }
            
            // escapeHtml is now provided by utils.js
            
            const storageManager = new StorageManager();
            await storageManager.init();
            console.log('‚úÖ Authors Page - Storage initialized');
            
            // Load available analyses
            await loadAnalysisList();
            console.log('‚úÖ Authors Page - Analysis list loaded');
            
            // Check for funding and repo filters in URL and pre-check checkbox
            const urlParams = new URLSearchParams(window.location.search);
            const repoParam = urlParams.get('repo');
            if (urlParams.get('funding') === 'true') {
                const fundingFilterCheckbox = document.getElementById('fundingFilter');
                if (fundingFilterCheckbox) {
                    fundingFilterCheckbox.checked = true;
                }
                // Show notice about funding filter
                const notice = document.createElement('div');
                notice.className = 'alert alert-info alert-dismissible fade show mt-3';
                notice.innerHTML = `
                    <i class="fas fa-heart me-2"></i>
                    <strong>Funding Filter Active:</strong> Showing only authors that accept personal sponsorships.
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                `;
                document.querySelector('.container').insertBefore(notice, document.querySelector('.container').firstChild);
            }
            
            // Store repoParam globally for use in loadAuthorData
            window.repoParam = repoParam;
            
            // Setup event listeners
            document.getElementById('analysisSelector').addEventListener('change', loadAuthorData);
            document.getElementById('ecosystemFilter').addEventListener('change', loadAuthorData);
            document.getElementById('locationFilter').addEventListener('change', loadAuthorData);
            document.getElementById('fundingFilter').addEventListener('change', loadAuthorData);
            document.getElementById('sanctionsFilter').addEventListener('change', loadAuthorData);
            
            // Display limit radio buttons
            const displayLimit25 = document.getElementById('displayLimit25');
            const displayLimitAll = document.getElementById('displayLimitAll');
            
            // Set initial state from localStorage
            if (displayLimit === 'all') {
                displayLimitAll.checked = true;
            } else {
                displayLimit25.checked = true;
            }
            
            if (displayLimit25) {
                displayLimit25.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        displayLimit = '25';
                        localStorage.setItem('authorsDisplayLimit', '25');
                        loadAuthorData();
                    }
                });
            }
            
            if (displayLimitAll) {
                displayLimitAll.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        displayLimit = 'all';
                        localStorage.setItem('authorsDisplayLimit', 'all');
                        loadAuthorData();
                    }
                });
            }
            
            // Map toggle buttons
            const showMapBtn = document.getElementById('showMapBtn');
            const toggleMapBtn = document.getElementById('toggleMapBtn');
            const authorMapCard = document.getElementById('authorMapCard');
            
            if (showMapBtn) {
                showMapBtn.addEventListener('click', function() {
                    authorMapCard.style.display = 'block';
                    showMapBtn.style.display = 'none';
                    // Initialize map if not already initialized
                    if (!authorMap && typeof L !== 'undefined') {
                        initializeMap();
                    }
                    // Populate map with all filtered authors (including single-package-single-repo) and invalidate size
                    setTimeout(() => {
                        if (authorMap && allFilteredAuthors && allFilteredAuthors.length > 0) {
                            displayAuthorMap(allFilteredAuthors).catch(err => 
                                console.warn('Failed to update author map:', err)
                            );
                            // Invalidate map size to ensure it renders correctly
                            authorMap.invalidateSize();
                        }
                    }, 100);
                });
            }
            
            if (toggleMapBtn) {
                toggleMapBtn.addEventListener('click', function() {
                    authorMapCard.style.display = 'none';
                    if (showMapBtn) {
                        showMapBtn.style.display = 'block';
                    }
                });
            }
            
            // Initialize map function
            function initializeMap() {
                if (!authorMap && typeof L !== 'undefined') {
                    authorMap = L.map('authorMap').setView([20, 0], 2);
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap contributors',
                        maxZoom: 19
                    }).addTo(authorMap);
                }
            }
            
            // Display author locations on map
            async function displayAuthorMap(authors) {
                if (!locationService || typeof L === 'undefined') {
                    console.warn('‚ö†Ô∏è LocationService or Leaflet not available');
                    return;
                }
                
                // Ensure map container is visible
                const mapContainer = document.getElementById('authorMap');
                if (!mapContainer || mapContainer.offsetParent === null) {
                    console.warn('‚ö†Ô∏è Map container is not visible, skipping marker display');
                    return;
                }
                
                // Initialize map if not already done
                if (!authorMap) {
                    initializeMap();
                    // Wait a bit for map to initialize
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                // Ensure map is properly sized
                if (authorMap) {
                    authorMap.invalidateSize();
                }
                
                // Clear existing markers
                if (authorMap) {
                    authorMap.eachLayer(function(layer) {
                        if (layer instanceof L.Marker) {
                            authorMap.removeLayer(layer);
                        }
                    });
                }
                
                // Get unique locations from authors
                const locationMap = new Map(); // location -> array of authors
                const originalToNormalized = new Map(); // original location -> normalized location
                
                authors.forEach(author => {
                    const location = author.metadata?.location || author.metadata?.company || null;
                    if (location && location.trim()) {
                        const originalLoc = location.trim();
                        // Normalize the location to match what batchGeocode will use
                        const normalizedLoc = locationService.normalizeLocationString(originalLoc);
                        
                        if (normalizedLoc) {
                            // Map original to normalized for lookup
                            originalToNormalized.set(originalLoc, normalizedLoc);
                            
                            // Use normalized location as key in locationMap
                            if (!locationMap.has(normalizedLoc)) {
                                locationMap.set(normalizedLoc, []);
                            }
                            locationMap.get(normalizedLoc).push(author);
                        }
                    }
                });
                
                if (locationMap.size === 0) {
                    console.log('‚ÑπÔ∏è No locations found for authors');
                    return;
                }
                
                console.log(`üó∫Ô∏è Processing ${locationMap.size} unique locations...`);
                console.log(`   Locations: ${Array.from(locationMap.keys()).join(', ')}`);
                
                // Helper function to add a marker to the map
                const addMarkerToMap = (location, geocoded) => {
                    // Validate geocoded data
                    if (!geocoded || typeof geocoded.lat !== 'number' || typeof geocoded.lng !== 'number') {
                        console.warn(`‚ö†Ô∏è Invalid geocoding data for location: ${location}`, geocoded);
                        return null;
                    }
                    
                    // Validate coordinates are within valid ranges
                    if (geocoded.lat < -90 || geocoded.lat > 90 || geocoded.lng < -180 || geocoded.lng > 180) {
                        console.warn(`‚ö†Ô∏è Invalid coordinates for location: ${location}`, geocoded);
                        return null;
                    }
                    
                    const authorsAtLocation = locationMap.get(location);
                    if (!authorsAtLocation || !Array.isArray(authorsAtLocation)) {
                        console.warn(`‚ö†Ô∏è No authors found for normalized location: "${location}"`);
                        return null;
                    }
                    
                    const authorCount = authorsAtLocation.length;
                    
                    // Create popup content
                    const authorNames = authorsAtLocation.slice(0, 5).map(a => escapeHtml(a.author)).join('<br>');
                    const moreText = authorCount > 5 ? `<br><strong>+ ${authorCount - 5} more</strong>` : '';
                    const popupContent = `
                        <div class="map-popup-content">
                            <strong>${escapeHtml(location)}</strong><br>
                            <small>${authorCount} author${authorCount !== 1 ? 's' : ''}</small>
                            <hr class="map-popup-hr">
                            ${authorNames}${moreText}
                        </div>
                    `;
                    
                    try {
                        // Create marker with default icon
                        const marker = L.marker([geocoded.lat, geocoded.lng], {
                            icon: L.icon({
                                iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
                                iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',
                                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                                iconSize: [25, 41],
                                iconAnchor: [12, 41],
                                popupAnchor: [1, -34],
                                shadowSize: [41, 41]
                            })
                        }).addTo(authorMap);
                        marker.bindPopup(popupContent);
                        return marker;
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Failed to create marker for location: ${location}`, error);
                        return null;
                    }
                };
                
                // Geocode locations (loads from cache first, then fetches missing ones incrementally)
                const locations = Array.from(locationMap.keys());
                let markerCount = 0;
                const markers = []; // Store all markers for bounds calculation
                
                // Helper to update map bounds
                const updateMapBounds = () => {
                    if (markers.length > 0 && authorMap) {
                        const group = new L.featureGroup(markers);
                        const bounds = group.getBounds();
                        if (bounds.isValid()) {
                            if (markers.length === 1) {
                                authorMap.setView(bounds.getCenter(), 10);
                            } else {
                                authorMap.fitBounds(bounds.pad(0.1));
                            }
                        }
                    }
                };
                
                // Start geocoding with callback for incremental updates
                const geocodePromise = locationService.batchGeocode(
                    locations,
                    (processed, total) => {
                        console.log(`üìç Geocoding progress: ${processed}/${total}`);
                    },
                    // Callback when a new location is geocoded from API (for incremental map updates)
                    (location, geocoded) => {
                        const marker = addMarkerToMap(location, geocoded);
                        if (marker) {
                            markers.push(marker);
                            markerCount++;
                            console.log(`üìç Added marker for ${location} at [${geocoded.lat}, ${geocoded.lng}]`);
                            updateMapBounds();
                        }
                    }
                );
                
                // Wait for geocoding to complete
                // batchGeocode loads from cache first (fast, markers added immediately via callback)
                // Then fetches missing locations incrementally (markers added as they're fetched)
                // The onNewLocation callback handles all marker additions (cached + new)
                await geocodePromise;
                
                // Final fit map bounds to show all markers (if not already done incrementally)
                if (markerCount > 0 && authorMap && markers.length > 0) {
                    // Collect all markers from map (in case some were added outside our tracking)
                    const allMarkers = [];
                    authorMap.eachLayer(function(layer) {
                        if (layer instanceof L.Marker) {
                            allMarkers.push(layer);
                        }
                    });
                    
                    if (allMarkers.length > 0) {
                        const group = new L.featureGroup(allMarkers);
                        const bounds = group.getBounds();
                        if (bounds.isValid()) {
                            if (allMarkers.length === 1) {
                                // Single marker - zoom to reasonable level
                                authorMap.setView(bounds.getCenter(), 10);
                            } else {
                                // Multiple markers - fit bounds with padding
                                authorMap.fitBounds(bounds.pad(0.1));
                            }
                        }
                    }
                }
                
                console.log(`‚úÖ Added ${markerCount} markers to map`);
                
                // If markers were added, ensure map is visible and properly sized
                if (markerCount > 0 && authorMap) {
                    authorMap.invalidateSize();
                } else if (markerCount === 0) {
                    console.warn('‚ö†Ô∏è No markers were added to the map. Check geocoding results.');
                }
            }
            
            // Load analysis list first
            await loadAnalysisList();
            
            // Load initial data
            console.log('üìä Authors Page - Loading initial author data...');
            await loadAuthorData();
            
            async function loadAnalysisList() {
                try {
                    console.log('üìã Loading analyses list for authors page...');
                    
                    // Ensure storage manager is initialized
                    if (!storageManager.initialized) {
                        await storageManager.init();
                    }
                    
                    const storageInfo = await storageManager.getStorageInfo();
                    console.log('üìã Authors Page - Storage info:', storageInfo);
                    console.log(`üìã Authors Page - Organizations: ${storageInfo.organizations.length}, Repositories: ${storageInfo.repositories.length}`);
                    
                    const selector = document.getElementById('analysisSelector');
                    if (!selector) {
                        console.error('‚ùå Analysis selector not found');
                        return;
                    }
                    
                    // Add combined option (already there, but ensure it exists)
                    const combinedOption = Array.from(selector.options).find(opt => opt.value === 'combined');
                    if (!combinedOption) {
                        const allOption = document.createElement('option');
                        allOption.value = 'combined';
                        allOption.textContent = 'Combined (All Scans)';
                        selector.insertBefore(allOption, selector.firstChild);
                    }
                    
                    // Add individual analyses
                    const allEntries = [...storageInfo.organizations, ...storageInfo.repositories];
                    console.log(`üìã Authors Page - Adding ${allEntries.length} entries to selector`);
                    
                    // Remove existing individual entries (keep combined option)
                    const optionsToRemove = Array.from(selector.options).filter(opt => opt.value !== 'combined');
                    optionsToRemove.forEach(opt => opt.remove());
                    
                    allEntries.forEach(entry => {
                        const option = document.createElement('option');
                        option.value = entry.name;
                        option.textContent = entry.name;
                        selector.appendChild(option);
                        console.log(`üìã Added option: ${entry.name}`);
                    });
                    
                    selector.disabled = false;
                    console.log(`‚úÖ Analysis selector populated with ${allEntries.length + 1} entries (including combined)`);
                } catch (error) {
                    console.error('‚ùå Error loading analyses list:', error);
                    console.error('   Error details:', error.stack);
                    const selector = document.getElementById('analysisSelector');
                    if (selector) {
                        selector.disabled = true;
                    }
                }
            }
            
            async function loadAuthorData() {
                const analysisId = document.getElementById('analysisSelector').value;
                const ecosystem = document.getElementById('ecosystemFilter').value;
                const location = document.getElementById('locationFilter').value;
                
                console.log(`üìä Authors Page - Loading data for: ${analysisId}, ecosystem: ${ecosystem}, location: ${location}`);
                
                let authorData;
                
                if (analysisId === 'combined') {
                    console.log('üìä Authors Page - Loading combined authors...');
                    authorData = await loadCombinedAuthors();
                } else {
                    console.log(`üìä Authors Page - Loading single analysis: ${analysisId}`);
                    authorData = await loadSingleAnalysisAuthors(analysisId);
                }
                
                console.log(`üìä Authors Page - Loaded ${authorData ? authorData.length : 0} authors`);
                
                // Filter by repository if repo parameter is present
                if (window.repoParam && authorData) {
                    authorData = authorData.filter(author => {
                        // Check if any of the author's packages are used in the specified repository
                        if (author.packageRepositories) {
                            return Object.values(author.packageRepositories).some(repos => 
                                repos && repos.includes(window.repoParam)
                            );
                        }
                        // Fallback: check repositories array
                        if (author.repositories && Array.isArray(author.repositories)) {
                            return author.repositories.includes(window.repoParam);
                        }
                        return false;
                    });
                    console.log(`üìä Authors Page - Filtered to ${authorData.length} authors for repo ${window.repoParam}`);
                }
                
                displayAuthors(authorData, ecosystem, location);
            }
            
            // Update location filter dropdown with unique locations from authors
            function updateLocationFilter(authors) {
                const locationFilter = document.getElementById('locationFilter');
                if (!locationFilter) return;
                
                // Get all unique locations from authors
                const locations = new Set();
                authors.forEach(author => {
                    const location = author.metadata?.location || author.metadata?.company || null;
                    if (location && location.trim()) {
                        locations.add(location.trim());
                    }
                });
                
                // Get current selected value
                const currentValue = locationFilter.value;
                
                // Clear existing options except "All Locations"
                locationFilter.innerHTML = '<option value="all">All Locations</option>';
                
                // Add location options sorted alphabetically
                const sortedLocations = Array.from(locations).sort();
                sortedLocations.forEach(loc => {
                    const option = document.createElement('option');
                    option.value = loc;
                    option.textContent = loc;
                    locationFilter.appendChild(option);
                });
                
                // Restore selection if it still exists
                if (currentValue && Array.from(locations).includes(currentValue)) {
                    locationFilter.value = currentValue;
                } else {
                    locationFilter.value = 'all';
                }
            }
            
            // Normalize author name for deduplication (remove case, spaces, special chars)
            function normalizeAuthorName(name) {
                return name.toLowerCase()
                    .replace(/\s+/g, '')
                    .replace(/[^a-z0-9]/g, '');
            }
            
            // Check if two author names likely refer to the same person
            function areSimilarAuthors(name1, name2) {
                const norm1 = normalizeAuthorName(name1);
                const norm2 = normalizeAuthorName(name2);
                
                // Exact match after normalization
                if (norm1 === norm2) return true;
                
                // Check if one is contained in the other (e.g., "sindresorhus" in "Sindre Sorhus")
                if (norm1.includes(norm2) || norm2.includes(norm1)) {
                    // Only if they're reasonably close in length
                    const lenRatio = Math.min(norm1.length, norm2.length) / Math.max(norm1.length, norm2.length);
                    if (lenRatio > 0.5) return true;
                }
                
                return false;
            }

            async function loadCombinedAuthors() {
                const storageInfo = await storageManager.getStorageInfo();
                const allAuthors = new Map();
                
                const allEntries = [...storageInfo.organizations, ...storageInfo.repositories];
                console.log(`üìä Authors Page - Combining authors from ${allEntries.length} entries`);
                
                for (const entry of allEntries) {
                    console.log(`üìä Authors Page - Loading data for: ${entry.name}`);
                    const data = await storageManager.loadAnalysisDataForOrganization(entry.name);
                    
                    if (data) {
                        console.log(`üìä Authors Page - Data structure for ${entry.name}:`, {
                            hasData: !!data.data,
                            hasAuthorAnalysis: !!data.data?.authorAnalysis,
                            hasAuthors: !!data.data?.authorAnalysis?.authors,
                            authorCount: data.data?.authorAnalysis?.authors?.length || 0
                        });
                    } else {
                        console.log(`‚ö†Ô∏è Authors Page - No data found for ${entry.name}`);
                    }
                    
                    // Check if authorAnalysis exists, otherwise rebuild from cache
                    let authorRefs = data?.data?.authorAnalysis?.authors;
                    
                    if (!authorRefs && window.indexedDBManager && data?.data?.allDependencies) {
                        // Rebuild authorAnalysis from cache if missing
                        console.log(`‚ö†Ô∏è Authors Page - authorAnalysis missing, rebuilding from cache for ${entry.name}`);
                        authorRefs = await rebuildAuthorAnalysisFromCache(data.data, entry.name);
                    }
                    
                    if (authorRefs && authorRefs.length > 0) {
                        console.log(`‚úÖ Authors Page - Found ${authorRefs.length} authors in ${entry.name}`);
                        
                        const isNewFormat = data?.data?.authorAnalysis?._cacheVersion === 3 || 
                                           (authorRefs.length > 0 && authorRefs[0].authorKey);
                        
                        if (isNewFormat && window.cacheManager) {
                            // NEW FORMAT: Resolve references from cache
                            for (const ref of authorRefs) {
                                const authorEntity = await window.cacheManager.getAuthorEntity(ref.authorKey);
                                let author = {
                                    author: authorEntity?.author || ref.authorKey.split(':')[1] || ref.authorKey,
                                    ecosystem: authorEntity?.ecosystem || ref.ecosystem,
                                    packages: ref.packages || [],
                                    packageRepositories: ref.packageRepositories || {},
                                    repositories: ref.repositories || [],
                                    repositoryCount: ref.repositoryCount || 0,
                                    count: ref.count || 0,
                                    funding: authorEntity?.funding || null,
                                    metadata: authorEntity?.metadata || null,
                                    authorKey: ref.authorKey // Store for enrichment
                                };
                                
                                // Enrich with country code if location exists but countryCode doesn't
                                author = await enrichAuthorWithCountryCode(author);
                                
                                // Try to find similar existing author
                                let foundKey = null;
                                for (const [existingKey, existingAuthor] of allAuthors.entries()) {
                                    const [existingEcosystem, existingName] = existingKey.split(':', 2);
                                    if (existingEcosystem === author.ecosystem && areSimilarAuthors(existingName, author.author)) {
                                        foundKey = existingKey;
                                        break;
                                    }
                                }
                                
                                if (foundKey) {
                                    // Merge with existing author
                                    const existing = allAuthors.get(foundKey);
                                    existing.count += author.count;
                                    existing.packages.push(...author.packages);
                                    existing.packages = [...new Set(existing.packages)];
                                    // Merge repository data
                                    if (author.packageRepositories) {
                                        Object.keys(author.packageRepositories).forEach(pkg => {
                                            if (!existing.packageRepositories[pkg]) {
                                                existing.packageRepositories[pkg] = [];
                                            }
                                            existing.packageRepositories[pkg].push(...author.packageRepositories[pkg]);
                                            existing.packageRepositories[pkg] = [...new Set(existing.packageRepositories[pkg])];
                                        });
                                    }
                                    // Keep the longer name
                                    if (author.author.length > existing.author.length) {
                                        existing.author = author.author;
                                    }
                                    // Merge metadata if available (preserve countryCode if it exists)
                                    if (author.metadata) {
                                        if (!existing.metadata) {
                                        existing.metadata = author.metadata;
                                        } else {
                                            // Merge metadata, preserving countryCode from either source
                                            existing.metadata = {
                                                ...existing.metadata,
                                                ...author.metadata,
                                                // Preserve countryCode if either has it
                                                countryCode: existing.metadata.countryCode || author.metadata.countryCode || null,
                                                country: existing.metadata.country || author.metadata.country || null
                                            };
                                        }
                                    }
                                    // Preserve authorKey for saving back to database
                                    if (author.authorKey && !existing.authorKey) {
                                        existing.authorKey = author.authorKey;
                                    }
                                    if (author.funding && !existing.funding) {
                                        existing.funding = author.funding;
                                    }
                                } else {
                                    // Add new author
                                    const key = ref.authorKey || `${author.ecosystem}:${author.author}`;
                                    allAuthors.set(key, { 
                                        ...author, 
                                        packages: [...author.packages],
                                        metadata: author.metadata || null
                                    });
                                }
                            }
                        } else {
                            // OLD FORMAT: Handle as before (backward compatibility)
                            data.data.authorAnalysis.authors.forEach(author => {
                                // Try to find similar existing author
                                let foundKey = null;
                                for (const [existingKey, existingAuthor] of allAuthors.entries()) {
                                    const [existingEcosystem, existingName] = existingKey.split(':', 2);
                                    if (existingEcosystem === author.ecosystem && areSimilarAuthors(existingName, author.author)) {
                                        foundKey = existingKey;
                                        break;
                                    }
                                }
                                
                                if (foundKey) {
                                    // Merge with existing author
                                    const existing = allAuthors.get(foundKey);
                                    existing.count += author.count;
                                    existing.packages.push(...author.packages);
                                    existing.packages = [...new Set(existing.packages)];
                                    // Keep the longer name (usually the full name)
                                    if (author.author.length > existing.author.length) {
                                        existing.author = author.author;
                                    }
                                    // Merge metadata if available
                                    if (author.metadata && !existing.metadata) {
                                        existing.metadata = author.metadata;
                                    }
                                } else {
                                    // Add new author
                                    const key = `${author.ecosystem}:${author.author}`;
                                    allAuthors.set(key, { 
                                        ...author, 
                                        packages: [...author.packages],
                                        metadata: author.metadata || null
                                    });
                                }
                            });
                        }
                    }
                }
                
                const result = Array.from(allAuthors.values())
                    .sort((a, b) => b.count - a.count);
                
                console.log(`üìä Authors Page - Combined total: ${result.length} unique authors`);
                return result;
            }
            
            // Helper function to rebuild authorAnalysis from cache
            async function rebuildAuthorAnalysisFromCache(analysisData, identifier) {
                if (!window.indexedDBManager || !window.cacheManager) {
                    console.warn('‚ö†Ô∏è Cannot rebuild: indexedDBManager or cacheManager not available');
                    return [];
                }
                
                try {
                    // Get all dependencies from analysis
                    const dependencies = analysisData.allDependencies || [];
                    if (dependencies.length === 0) {
                        return [];
                    }
                    
                    // Get all package-author relationships
                    const allPackageAuthors = await window.indexedDBManager.getAllPackageAuthors();
                    
                    // Build a map of packageKey -> authorKeys
                    const packageAuthorMap = new Map();
                    allPackageAuthors.forEach(pa => {
                        if (!packageAuthorMap.has(pa.packageKey)) {
                            packageAuthorMap.set(pa.packageKey, []);
                        }
                        packageAuthorMap.get(pa.packageKey).push(pa.authorKey);
                    });
                    
                    // Build author references from dependencies
                    const authorMap = new Map(); // authorKey -> author data
                    
                    dependencies.forEach(dep => {
                        if (!dep.purl) return;
                        
                        // Extract ecosystem and name from PURL
                        const purlMatch = dep.purl.match(/pkg:([^\/]+)\/(.+)/);
                        if (!purlMatch) return;
                        
                        const ecosystem = purlMatch[1];
                        const packageName = purlMatch[2].split('@')[0];
                        const packageKey = `${ecosystem}:${packageName}`;
                        
                        // Get authors for this package
                        const authorKeys = packageAuthorMap.get(packageKey) || [];
                        const repositories = dep.repositories || [];
                        
                        authorKeys.forEach(authorKey => {
                            if (!authorMap.has(authorKey)) {
                                authorMap.set(authorKey, {
                                    authorKey: authorKey,
                                    ecosystem: ecosystem,
                                    packages: [],
                                    packageRepositories: {},
                                    repositories: [],
                                    repositoryCount: 0,
                                    count: 0
                                });
                            }
                            
                            const authorRef = authorMap.get(authorKey);
                            authorRef.packages.push(packageName);
                            authorRef.count++;
                            
                            // Track repositories
                            repositories.forEach(repo => {
                                if (!authorRef.packageRepositories[packageName]) {
                                    authorRef.packageRepositories[packageName] = [];
                                }
                                if (!authorRef.packageRepositories[packageName].includes(repo)) {
                                    authorRef.packageRepositories[packageName].push(repo);
                                }
                                if (!authorRef.repositories.includes(repo)) {
                                    authorRef.repositories.push(repo);
                                }
                            });
                        });
                    });
                    
                    // Calculate repository counts
                    authorMap.forEach(authorRef => {
                        authorRef.packages = [...new Set(authorRef.packages)];
                        authorRef.repositoryCount = authorRef.repositories.length;
                    });
                    
                    const authorRefs = Array.from(authorMap.values());
                    console.log(`‚úÖ Rebuilt ${authorRefs.length} author references from cache`);
                    return authorRefs;
                } catch (error) {
                    console.error('‚ùå Failed to rebuild authorAnalysis from cache:', error);
                    return [];
                }
            }
            
            async function loadSingleAnalysisAuthors(analysisId) {
                console.log(`üìä Authors Page - Loading single analysis: ${analysisId}`);
                const data = await storageManager.loadAnalysisDataForOrganization(analysisId);
                
                if (data) {
                    console.log(`üìä Authors Page - Data for ${analysisId}:`, {
                        hasData: !!data.data,
                        hasAuthorAnalysis: !!data.data?.authorAnalysis,
                        hasAuthors: !!data.data?.authorAnalysis?.authors,
                        authorCount: data.data?.authorAnalysis?.authors?.length || 0,
                        cacheVersion: data.data?.authorAnalysis?._cacheVersion
                    });
                } else {
                    console.log(`‚ö†Ô∏è Authors Page - No data found for ${analysisId}`);
                }
                
                // Check if authorAnalysis exists, otherwise rebuild from cache
                let authorRefs = data?.data?.authorAnalysis?.authors;
                
                if (!authorRefs && window.indexedDBManager && data?.data?.allDependencies) {
                    // Rebuild authorAnalysis from cache if missing
                    console.log(`‚ö†Ô∏è Authors Page - authorAnalysis missing, rebuilding from cache for ${analysisId}`);
                    authorRefs = await rebuildAuthorAnalysisFromCache(data.data, analysisId);
                }
                
                if (!authorRefs) {
                    authorRefs = [];
                }
                
                // Check if this is new format (references) or old format (full data)
                const isNewFormat = data?.data?.authorAnalysis?._cacheVersion === 3 || 
                                   (authorRefs.length > 0 && authorRefs[0].authorKey);
                
                if (isNewFormat && window.cacheManager) {
                    // NEW FORMAT: Resolve author references from cache
                    console.log(`üì¶ Authors Page - Resolving ${authorRefs.length} author references from cache...`);
                    const authors = await Promise.all(
                        authorRefs.map(async (ref) => {
                            const authorEntity = await window.cacheManager.getAuthorEntity(ref.authorKey);
                            let author;
                            if (authorEntity) {
                                author = {
                                    author: authorEntity.author || ref.authorKey.split(':')[1],
                                    ecosystem: authorEntity.ecosystem || ref.ecosystem,
                                    packages: ref.packages || [],
                                    packageRepositories: ref.packageRepositories || {},
                                    repositories: ref.repositories || [],
                                    repositoryCount: ref.repositoryCount || 0,
                                    count: ref.count || 0,
                                    funding: authorEntity.funding || null,
                                    metadata: authorEntity.metadata || null,
                                    authorKey: ref.authorKey // Store for enrichment
                                };
                            } else {
                                // Fallback if cache miss
                                const [, authorName] = ref.authorKey.split(':');
                                author = {
                                    author: authorName || ref.authorKey,
                                    ecosystem: ref.ecosystem,
                                    packages: ref.packages || [],
                                    packageRepositories: ref.packageRepositories || {},
                                    repositories: ref.repositories || [],
                                    repositoryCount: ref.repositoryCount || 0,
                                    count: ref.count || 0,
                                    funding: null,
                                    metadata: null,
                                    authorKey: ref.authorKey // Store for enrichment
                                };
                            }
                            
                            // Enrich with country code if location exists but countryCode doesn't
                            return await enrichAuthorWithCountryCode(author);
                        })
                    );
                    console.log(`‚úÖ Authors Page - Resolved ${authors.length} authors from cache`);
                    return authors;
                } else {
                    // OLD FORMAT: Return as-is (backward compatibility)
                    console.log(`üìä Authors Page - Using legacy format (${authorRefs.length} authors)`);
                    return authorRefs;
                }
            }
            
            function showPackageModal(author) {
                const modal = new bootstrap.Modal(document.getElementById('packageModal'));
                const uniquePackages = [...new Set(author.packages)].sort();
                const packageRepositories = author.packageRepositories || {};
                const repositoryCount = author.repositoryCount || 0;
                
                document.getElementById('packageModalLabel').textContent = 
                    `${uniquePackages.length} Package${uniquePackages.length !== 1 ? 's' : ''} by ${author.author}`;
                
                // Get current organization context for links
                const currentOrg = document.getElementById('analysisSelector')?.value || 'combined';
                const orgParamForLink = (currentOrg === 'combined' || currentOrg === 'Combined (All Scans)') ? null : currentOrg;
                
                // Helper function to create deps.html URL with package search filter
                const createPackageLink = (packageName) => {
                    const params = new URLSearchParams();
                    if (orgParamForLink) {
                        params.set('org', orgParamForLink);
                    }
                    params.set('search', packageName);
                    return `deps.html?${params.toString()}`;
                };
                
                // Helper function to create deps.html URL with repo filter
                const createRepoLink = (repo) => {
                    const params = new URLSearchParams();
                    if (orgParamForLink) {
                        params.set('org', orgParamForLink);
                    }
                    params.set('repo', repo);
                    return `deps.html?${params.toString()}`;
                };
                
                let html = `
                    <div class="mb-3">
                        <strong>Ecosystem:</strong> <span class="badge bg-info">${author.ecosystem}</span><br>
                        <strong>Total Packages:</strong> <span class="badge bg-primary">${uniquePackages.length}</span><br>
                        <strong>Repository Usage:</strong> <span class="badge bg-secondary">${repositoryCount} repo${repositoryCount !== 1 ? 's' : ''}</span>
                    </div>
                    <div class="list-group max-h-400 overflow-y-auto">
                `;
                
                uniquePackages.forEach(pkg => {
                    const repos = packageRepositories[pkg] || [];
                    const repoCount = repos.length;
                    
                    html += `
                        <div class="list-group-item">
                            <div class="d-flex justify-content-between align-items-start">
                                <div class="flex-grow-1">
                                    <strong><a href="${createPackageLink(pkg)}" class="text-decoration-none" target="_blank">${escapeHtml(pkg)}</a></strong>
                                    ${repoCount > 0 ? `
                                        <br><small class="text-muted">
                                            <i class="fas fa-folder me-1"></i>
                                            Used in <strong>${repoCount}</strong> repositor${repoCount !== 1 ? 'ies' : 'y'}
                                        </small>
                                    ` : ''}
                                </div>
                                ${repoCount > 0 ? `<span class="badge bg-secondary ms-2">${repoCount}</span>` : ''}
                            </div>
                            ${repoCount > 0 && repoCount <= 10 ? `
                                <div class="mt-2">
                                    <small class="text-muted">
                                        <i class="fas fa-code-branch me-1"></i>
                                        ${repos.map(r => `<a href="${createRepoLink(r)}" class="text-decoration-none" target="_blank"><code>${escapeHtml(r)}</code></a>`).join(', ')}
                                    </small>
                                </div>
                            ` : repoCount > 10 ? `
                                <div class="mt-2">
                                    <small class="text-muted">
                                        <i class="fas fa-code-branch me-1"></i>
                                        ${repos.slice(0, 5).map(r => `<a href="${createRepoLink(r)}" class="text-decoration-none" target="_blank"><code>${escapeHtml(r)}</code></a>`).join(', ')}
                                        <strong>+ ${repoCount - 5} more</strong>
                                    </small>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                html += '</div>';
                
                document.getElementById('packageModalContent').innerHTML = html;
                modal.show();
            }
            
        // Normalize GitHub username for URL generation (replace [bot] with -bot)
        function normalizeGitHubUsername(username) {
            if (!username || typeof username !== 'string') return username;
            // Replace [bot] suffix with -bot for GitHub URLs
            // e.g., "dependabot[bot]" -> "dependabot-bot"
            return username.replace(/\[bot\]$/i, '-bot');
        }
        
        // Cache for validated URLs to avoid repeated checks
        const urlValidationCache = new Map();
        
        // Validate URL exists (check HEAD request)
        async function validateUrl(url) {
            if (!url || typeof url !== 'string') return false;
            
            // Check cache first
            if (urlValidationCache.has(url)) {
                return urlValidationCache.get(url);
            }
            
            try {
                // Use HEAD request to check if URL exists without downloading content
                const response = await fetch(url, {
                    method: 'HEAD',
                    mode: 'no-cors', // CORS might fail, but we can still check
                    cache: 'no-cache'
                });
                
                // For no-cors mode, we can't read status, so assume it's valid
                // For same-origin or CORS-enabled, check status
                const isValid = response.ok || response.status === 0;
                urlValidationCache.set(url, isValid);
                return isValid;
            } catch (error) {
                // If fetch fails, try a different approach: check if it's a known pattern
                // For GitHub, check if it's a known organization/user pattern
                if (url.includes('github.com/')) {
                    const githubMatch = url.match(/github\.com\/([^\/]+)/);
                    if (githubMatch) {
                        const username = githubMatch[1];
                        // Known GitHub organizations that exist
                        const knownOrgs = ['actions', 'google', 'microsoft', 'facebook', 'apple', 'amazon', 'netflix', 'twitter', 'github'];
                        if (knownOrgs.includes(username.toLowerCase())) {
                            urlValidationCache.set(url, true);
                            return true;
                        }
                    }
                }
                
                // For PyPI, check known patterns
                if (url.includes('pypi.org/')) {
                    // PyPI URLs are generally valid if they follow the pattern
                    // We'll be conservative and only exclude obviously invalid ones
                    urlValidationCache.set(url, true);
                    return true;
                }
                
                // Default: assume invalid if fetch fails
                urlValidationCache.set(url, false);
                return false;
            }
        }
        
        // Validate GitHub user/organization exists
        async function validateGitHubUser(username) {
            if (!username) return false;
            const normalized = normalizeGitHubUsername(username);
            const url = `https://github.com/${encodeURIComponent(normalized)}`;
            return await validateUrl(url);
        }
        
        // Validate PyPI user/organization exists
        async function validatePyPIUser(username, isOrg = false) {
            if (!username) return false;
            const url = isOrg 
                ? `https://pypi.org/org/${encodeURIComponent(username)}/`
                : `https://pypi.org/user/${encodeURIComponent(username)}/`;
            return await validateUrl(url);
        }
        
        // Check if author is an organization
        function isOrganization(author) {
            // Check metadata type
            if (author.metadata?.type === 'Organization' || author.metadata?.type === 'organization') {
                return true;
            }
            // Check GitHub type
            if (author.metadata?.github_type === 'Organization') {
                return true;
            }
            // Check if marked as PyPI organization
            if (author.metadata?.pypi_organization) {
                return true;
            }
            // Check common organization names (GitHub Actions organizations)
            const orgNames = ['actions', 'google', 'microsoft', 'facebook', 'apple', 'amazon', 'netflix', 'twitter', 'github'];
            const authorLower = (author.author || '').toLowerCase();
            if (orgNames.includes(authorLower)) {
                return true;
            }
            // Check if ecosystem is GitHub Actions and name is single word (likely org)
            if (author.ecosystem === 'githubactions' || author.ecosystem === 'GitHub Actions') {
                const authorName = (author.author || '').trim();
                if (authorName && !authorName.includes(' ') && !authorName.includes(',') && authorName.length > 0) {
                    return true;
                }
            }
            return false;
        }
        
        // Generate registry profile URLs only if we have verified data
        async function getVerifiedProfileLinks(author) {
            const links = [];
            
            // Only show npm profile if we have verified username from metadata
            // npm profiles use the username (from maintainers[].name), not the display name (from author.name)
            // e.g., username "tmpvar" not display name "Elijah Insua", or "shama" not "Kyle Robinson Young"
            if (author.ecosystem === 'npm' && author.metadata?.npm_username) {
                // Use verified npm_username from metadata (from maintainers[].name or ecosyste.ms login)
                const npmUsername = author.metadata.npm_username;
                // Only show if username looks valid (no spaces, not empty)
                if (npmUsername && !npmUsername.includes(' ')) {
                    links.push({
                        url: `https://www.npmjs.com/~${encodeURIComponent(npmUsername)}`,
                        icon: 'fab fa-npm',
                        label: 'npm Profile',
                        class: 'btn-outline-danger'
                    });
                }
            }
            
            // PyPI profile - handle both organizations and users
            // NOTE: PyPI JSON API doesn't provide explicit organization field
            // We detect organizations from patterns in the JSON response (name + email domain analysis)
            if (author.ecosystem === 'pypi' && author.author) {
                // Check metadata first (organization detection done during extraction)
                if (author.metadata?.pypi_organization) {
                    // This is an organization (detected from PyPI JSON patterns)
                    links.push({
                        url: `https://pypi.org/org/${encodeURIComponent(author.metadata.pypi_organization)}/`,
                        icon: 'fas fa-cube',
                        label: 'PyPI Organization',
                        class: 'btn-outline-primary'
                    });
                } else if (author.metadata?.pypi_username) {
                    // This is a user with known username
                    links.push({
                        url: `https://pypi.org/user/${encodeURIComponent(author.metadata.pypi_username)}/`,
                        icon: 'fas fa-cube',
                        label: 'PyPI Profile',
                        class: 'btn-outline-primary'
                    });
                }
                // NOTE: Removed fallback URL generation to prevent 404s
                // Only generate URLs when we have verified metadata (pypi_organization or pypi_username)
            }
            
            // Crates.io profile - only show if we have verified username
            if (author.ecosystem === 'cargo' && author.metadata?.cargo_username) {
                const cargoUsername = author.metadata.cargo_username;
                if (cargoUsername && !cargoUsername.includes(' ')) {
                    links.push({
                        url: `https://crates.io/users/${encodeURIComponent(cargoUsername)}`,
                        icon: 'fas fa-box',
                        label: 'Crates.io Profile',
                        class: 'btn-outline-warning'
                    });
                }
            }
            
            // RubyGems profile
            // RubyGems uses lowercase usernames (e.g., "parkr" not "Parker Moore")
            // Only show if we have verified username from metadata (ecosyste.ms login)
            if (author.ecosystem === 'gem' && author.metadata?.rubygems_username) {
                const rubygemsUsername = author.metadata.rubygems_username;
                // Only show if username looks valid (no spaces, not empty)
                if (rubygemsUsername && !rubygemsUsername.includes(' ')) {
                    links.push({
                        url: `https://rubygems.org/profiles/${encodeURIComponent(rubygemsUsername)}`,
                        icon: 'fas fa-gem',
                        label: 'RubyGems Profile',
                        class: 'btn-outline-danger'
                    });
                }
            }
            
            // GitHub profile (only if we extracted from repo or it's a github: prefixed author)
            if (author.ecosystem === 'github' || author.metadata?.github) {
                const githubUsername = normalizeGitHubUsername(author.metadata?.github || author.author);
                // Only add if username is valid (not empty, not just spaces)
                if (githubUsername && githubUsername.trim()) {
                    const url = `https://github.com/${encodeURIComponent(githubUsername)}`;
                    // Validate URL before adding (async validation will be done separately)
                    links.push({
                        url: url,
                        icon: 'fab fa-github',
                        label: author.metadata?.github_type === 'Organization' ? 'GitHub Organization' : 'GitHub Profile',
                        class: 'btn-outline-secondary',
                        needsValidation: true
                    });
                }
            }
            
            return links;
        }
        
        // Validate and open URL (called on link click)
        async function validateAndOpenUrl(url) {
            if (!url) return;
            
            // Check cache first
            if (urlValidationCache.has(url)) {
                const isValid = urlValidationCache.get(url);
                if (isValid) {
                    window.open(url, '_blank', 'noreferrer,noopener');
                } else {
                    alert(`‚ö†Ô∏è This URL appears to be invalid (404): ${url}`);
                }
                return;
            }
            
            // Try to validate URL
            try {
                const isValid = await validateUrl(url);
                urlValidationCache.set(url, isValid);
                
                if (isValid) {
                    window.open(url, '_blank', 'noreferrer,noopener');
                } else {
                    // Still open the URL but warn user
                    console.warn(`‚ö†Ô∏è URL validation failed for: ${url}`);
                    const userConfirm = confirm(`‚ö†Ô∏è Warning: This URL may not exist (404).\n\n${url}\n\nDo you want to open it anyway?`);
                    if (userConfirm) {
                        window.open(url, '_blank', 'noreferrer,noopener');
                    }
                }
            } catch (error) {
                // If validation fails, still allow opening (might be CORS issue)
                console.warn(`‚ö†Ô∏è URL validation error for ${url}:`, error);
                window.open(url, '_blank', 'noreferrer,noopener');
            }
        }

        // Generate social profile icons for table display
        // Note: URL validation happens on-demand when links are clicked to avoid blocking rendering
        function getSocialProfileIcons(author) {
            const icons = [];
            
            // GitHub profile (always check metadata.github, regardless of ecosystem)
            if (author.metadata?.github) {
                const githubUsername = normalizeGitHubUsername(author.metadata.github);
                if (githubUsername && githubUsername.trim()) {
                    // Only add if username looks valid (not empty, reasonable length)
                    // Full validation happens on click via link handler
                    icons.push({
                        url: `https://github.com/${encodeURIComponent(githubUsername)}`,
                        icon: 'fab fa-github',
                        title: author.metadata?.github_type === 'Organization' ? 'GitHub Organization' : 'GitHub Profile',
                        color: 'text-dark'
                    });
                }
            }
            
            // npm profile - only show if we have verified username
            if (author.ecosystem === 'npm' && author.metadata?.npm_username) {
                const npmUsername = author.metadata.npm_username;
                if (npmUsername && !npmUsername.includes(' ')) {
                    icons.push({
                        url: `https://www.npmjs.com/~${encodeURIComponent(npmUsername)}`,
                        icon: 'fab fa-npm',
                        title: 'npm Profile',
                        color: 'text-danger'
                    });
                }
            }
            
            // PyPI profile
            if (author.ecosystem === 'pypi' && author.author) {
                if (author.metadata?.pypi_organization) {
                    // Only add if organization name looks valid
                    icons.push({
                        url: `https://pypi.org/org/${encodeURIComponent(author.metadata.pypi_organization)}/`,
                        icon: 'fas fa-cube',
                        title: 'PyPI Organization',
                        color: 'text-primary'
                    });
                } else if (author.metadata?.pypi_username) {
                    // Only add if username looks valid
                    icons.push({
                        url: `https://pypi.org/user/${encodeURIComponent(author.metadata.pypi_username)}/`,
                        icon: 'fas fa-cube',
                        title: 'PyPI Profile',
                        color: 'text-primary'
                    });
                }
                // NOTE: Removed fallback URL generation to prevent 404s
                // Only generate URLs when we have verified metadata (pypi_organization or pypi_username)
            }
            
            // RubyGems profile - only show if we have verified username
            if (author.ecosystem === 'gem' && author.metadata?.rubygems_username) {
                const rubygemsUsername = author.metadata.rubygems_username;
                if (rubygemsUsername && !rubygemsUsername.includes(' ')) {
                    icons.push({
                        url: `https://rubygems.org/profiles/${encodeURIComponent(rubygemsUsername)}`,
                        icon: 'fas fa-gem',
                        title: 'RubyGems Profile',
                        color: 'text-danger'
                    });
                }
            }
            
            return icons;
        }

            async function showAuthorDetailsModal(author) {
                const modal = new bootstrap.Modal(document.getElementById('authorDetailsModal'));
                document.getElementById('authorDetailsModalLabel').textContent = author.author;
                
                const allPackages = [...new Set(author.packages)].sort();
                const uniquePackageCount = allPackages.length;
                const occurrenceCount = author.count; // How many times author was found across dependencies
                const repositoryCount = author.repositoryCount || 0;
                const packageRepositories = author.packageRepositories || {};
                
                let html = `
                    <div class="mb-3">
                        <h6><i class="fas fa-user me-2"></i>Basic Information</h6>
                        <table class="table table-sm table-borderless">
                            <tr>
                                <td class="w-140"><strong>Name:</strong></td>
                                <td>${author.author}</td>
                            </tr>
                            <tr>
                                <td><strong>Ecosystem:</strong></td>
                                <td><span class="badge bg-info">${author.ecosystem}</span></td>
                            </tr>
                            <tr>
                                <td><strong>Package Count:</strong></td>
                                <td>
                                    <span class="badge bg-primary">${uniquePackageCount}</span>
                                    ${occurrenceCount > uniquePackageCount ? `<small class="text-muted ms-2">(${occurrenceCount} occurrences)</small>` : ''}
                                </td>
                            </tr>
                            <tr>
                                <td><strong>Repository Usage:</strong></td>
                                <td>
                                    <span class="badge bg-secondary">${repositoryCount} repo${repositoryCount !== 1 ? 's' : ''}</span>
                                    ${repositoryCount >= 5 ? '<span class="badge bg-danger ms-2" title="High risk: Single point of failure">High Risk</span>' : ''}
                                    ${repositoryCount >= 3 && repositoryCount < 5 ? '<span class="badge bg-warning text-dark ms-2" title="Moderate risk">Moderate Risk</span>' : ''}
                                </td>
                            </tr>
                        </table>
                    </div>
                `;
                
            // Verified Profile Links
            const verifiedLinks = getVerifiedProfileLinks(author);
            
            if (verifiedLinks.length > 0) {
                html += `
                    <div class="mb-3">
                        <h6><i class="fas fa-link me-2"></i>Profile Links</h6>
                        <div class="d-flex flex-wrap gap-2">
                `;
                
                verifiedLinks.forEach(link => {
                    html += `
                        <a href="${link.url}" target="_blank" class="btn btn-sm ${link.class}">
                            <i class="${link.icon} me-1"></i>
                            ${link.label}
                        </a>
                    `;
                });
                
                // Ecosyste.ms profile for aggregate stats
                const ecosystemMap = {
                    'npm': 'npmjs.org',
                    'pypi': 'pypi.org',
                    'cargo': 'crates.io',
                    'gem': 'rubygems.org',
                    'nuget': 'nuget.org',
                    'packagist': 'packagist.org'
                };
                const registryName = ecosystemMap[author.ecosystem.toLowerCase()];
                if (registryName) {
                    // For ecosyste.ms, use the correct identifier for each ecosystem
                    // Only generate link if we have verified username (not display name)
                    let maintainerIdentifier = null;
                    
                    // For PyPI, use pypi_username from metadata
                    if (author.ecosystem === 'pypi' && author.metadata?.pypi_username) {
                        maintainerIdentifier = author.metadata.pypi_username;
                    }
                    // For npm, use npm_username from metadata (not display name)
                    else if (author.ecosystem === 'npm' && author.metadata?.npm_username) {
                        maintainerIdentifier = author.metadata.npm_username;
                    }
                    // For RubyGems, use rubygems_username from metadata
                    else if (author.ecosystem === 'gem' && author.metadata?.rubygems_username) {
                        maintainerIdentifier = author.metadata.rubygems_username;
                    }
                    // For Cargo, use cargo_username from metadata
                    else if (author.ecosystem === 'cargo' && author.metadata?.cargo_username) {
                        maintainerIdentifier = author.metadata.cargo_username;
                    }
                    
                    // Only show link if we have verified username
                    if (maintainerIdentifier) {
                        html += `
                            <a href="https://packages.ecosyste.ms/registries/${registryName}/maintainers/${encodeURIComponent(maintainerIdentifier)}" target="_blank" class="btn btn-sm btn-outline-info">
                                <i class="fas fa-chart-bar me-1"></i>
                                Package Statistics
                            </a>
                        `;
                    }
                }
                
                html += '</div></div>';
            }
                
                // Show metadata if available
                if (author.metadata) {
                    html += `
                        <div class="mb-3">
                            <h6><i class="fas fa-info-circle me-2"></i>Additional Details</h6>
                            <table class="table table-sm table-borderless">
                    `;
                    
                    if (author.metadata.email) {
                        html += `
                            <tr>
                                <td class="w-140"><strong>Email:</strong></td>
                                <td><a href="mailto:${author.metadata.email}">${author.metadata.email}</a></td>
                            </tr>
                        `;
                    }
                    
                    if (author.metadata.github) {
                        const githubUsername = normalizeGitHubUsername(author.metadata.github);
                        html += `
                            <tr>
                                <td><strong>GitHub:</strong></td>
                                <td><a href="https://github.com/${escapeHtml(githubUsername)}" target="_blank">
                                    <i class="fab fa-github me-1"></i>${escapeHtml(author.metadata.github)}
                                </a></td>
                            </tr>
                        `;
                    }
                    
                    if (author.metadata.url) {
                        html += `
                            <tr>
                                <td><strong>Website:</strong></td>
                                <td><a href="${author.metadata.url}" target="_blank">${author.metadata.url}</a></td>
                            </tr>
                        `;
                    }
                    
                    if (author.metadata.location) {
                        let locationDisplay = `<i class="fas fa-map-marker-alt me-1 text-muted"></i>${escapeHtml(author.metadata.location)}`;
                        // Check for sanctioned countries (check all country codes if multiple)
                        const countryCodesToCheck = author.metadata?.countryCodes || (author.metadata?.countryCode ? [author.metadata.countryCode] : []);
                        if (countryCodesToCheck.length > 0 && sanctionsService) {
                            const sanctionedCountries = [];
                            countryCodesToCheck.forEach(code => {
                                const sanctionCheck = sanctionsService.checkSanctioned(code);
                                if (sanctionCheck.isSanctioned) {
                                    const sources = sanctionCheck.sources.join(', ');
                                    sanctionedCountries.push({ code, sources });
                                }
                            });
                            if (sanctionedCountries.length > 0) {
                                const allSources = [...new Set(sanctionedCountries.flatMap(s => s.sources.split(', ')))].join(', ');
                                const codes = sanctionedCountries.map(s => s.code).join(', ');
                                locationDisplay += ` <span class="badge bg-danger ms-2" title="Sanctioned country (${allSources}): ${escapeHtml(codes)}">üö´ ${allSources}</span>`;
                            }
                        }
                        html += `
                            <tr>
                                <td><strong>Location:</strong></td>
                                <td>${locationDisplay}</td>
                            </tr>
                        `;
                    }
                    
                    if (author.metadata.company) {
                        html += `
                            <tr>
                                <td><strong>Company:</strong></td>
                                <td><i class="fas fa-building me-1 text-muted"></i>${escapeHtml(author.metadata.company)}</td>
                            </tr>
                        `;
                    }
                    
                    // Show country code(s) if available
                    if (author.metadata.countryCode || author.metadata.countryCodes) {
                        let countryDisplay = '';
                        if (author.metadata.countryCodes && author.metadata.countryCodes.length > 1) {
                            // Multiple countries
                            const codes = author.metadata.countryCodes.map(code => escapeHtml(code)).join(', ');
                            const countries = author.metadata.countries ? ` (${author.metadata.countries.map(c => escapeHtml(c)).join(', ')})` : '';
                            countryDisplay = `${codes}${countries}`;
                        } else {
                            // Single country
                            const code = author.metadata.countryCode || author.metadata.countryCodes?.[0] || '';
                            countryDisplay = `${escapeHtml(code)}${author.metadata.country ? ` (${escapeHtml(author.metadata.country)})` : ''}`;
                        }
                        html += `
                            <tr>
                                <td><strong>Country:</strong></td>
                                <td>${countryDisplay}</td>
                            </tr>
                        `;
                    }
                    
                    // Show tentative correlation warning if present
                    if (author.metadata.tentative_correlation) {
                        html += `
                            <tr>
                                <td><strong>Correlation:</strong></td>
                                <td>
                                    <span class="badge bg-warning text-dark">
                                        <i class="fas fa-exclamation-triangle me-1"></i>Tentative
                                    </span>
                                    <small class="text-muted ms-2">
                                        ${author.metadata.correlation_source === 'github_contributor' 
                                            ? 'Correlated via GitHub contributor (same user ID)' 
                                            : 'Tentative correlation'}
                                    </small>
                                </td>
                            </tr>
                        `;
                    }
                    
                    html += '</table></div>';
                }
                
                // Sponsorship & Support Info - Only show if author has funding metadata (author-level, not package-level)
                if (author.funding) {
                    html += `
                        <div class="mb-3">
                            <h6><i class="fas fa-heart me-2"></i>Author Sponsorship Available</h6>
                            <div class="alert alert-success mb-2">
                                <small>
                                    <i class="fas fa-check-circle me-1"></i>
                                    <strong>${author.author}</strong> is accepting personal sponsorships (author-level support).
                                    They maintain ${uniquePackageCount} package${uniquePackageCount !== 1 ? 's' : ''} used by your project.
                                </small>
                            </div>
                            <div class="d-flex flex-wrap gap-2">
                    `;
                    
                    // Show platform-specific links if available (using secure URL validation)
                    if (author.funding.github || (author.funding.url && isUrlFromHostname(author.funding.url, 'github.com', '/sponsors'))) {
                        const githubSponsorUsername = normalizeGitHubUsername(author.metadata?.github || author.author);
                        html += `
                            <a href="https://github.com/sponsors/${encodeURIComponent(githubSponsorUsername)}" target="_blank" class="btn btn-sm btn-outline-danger">
                                <i class="fas fa-heart me-1"></i>GitHub Sponsors
                            </a>
                        `;
                    }
                    
                    if (author.funding.opencollective || (author.funding.url && isUrlFromHostname(author.funding.url, 'opencollective.com'))) {
                        // Securely extract Open Collective username from URL
                        let ocUsername = author.author;
                        if (author.funding.url && isUrlFromHostname(author.funding.url, 'opencollective.com')) {
                            try {
                                const url = new URL(author.funding.url.startsWith('http') ? author.funding.url : 'https://' + author.funding.url);
                                const pathParts = url.pathname.split('/').filter(p => p);
                                if (pathParts.length > 0) {
                                    ocUsername = pathParts[0];
                                }
                            } catch (e) {
                                // If URL parsing fails, use author name as fallback
                                ocUsername = author.author;
                            }
                        }
                        html += `
                            <a href="https://opencollective.com/${encodeURIComponent(ocUsername)}" target="_blank" class="btn btn-sm btn-outline-primary">
                                <i class="fas fa-hand-holding-usd me-1"></i>Open Collective
                            </a>
                        `;
                    }
                    
                    if (author.funding.patreon || (author.funding.url && isUrlFromHostname(author.funding.url, 'patreon.com'))) {
                        html += `
                            <a href="${author.funding.url || `https://patreon.com/${encodeURIComponent(author.author)}`}" target="_blank" class="btn btn-sm btn-outline-danger">
                                <i class="fab fa-patreon me-1"></i>Patreon
                            </a>
                        `;
                    }
                    
                    // Show generic funding URL if no specific platform detected
                    if (author.funding.url && !author.funding.github && !author.funding.opencollective && !author.funding.patreon) {
                        html += `
                            <a href="${author.funding.url}" target="_blank" class="btn btn-sm btn-outline-info">
                                <i class="fas fa-donate me-1"></i>Support
                            </a>
                        `;
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
                
                // Get current organization context for links
                const currentOrg = document.getElementById('analysisSelector')?.value || 'combined';
                const orgParamForLink = (currentOrg === 'combined' || currentOrg === 'Combined (All Scans)') ? null : currentOrg;
                
                // Helper function to create deps.html URL with package search filter
                const createPackageLink = (packageName) => {
                    const params = new URLSearchParams();
                    if (orgParamForLink) {
                        params.set('org', orgParamForLink);
                    }
                    params.set('search', packageName);
                    return `deps.html?${params.toString()}`;
                };
                
                // Helper function to create deps.html URL with repo filter
                const createRepoLink = (repo) => {
                    const params = new URLSearchParams();
                    if (orgParamForLink) {
                        params.set('org', orgParamForLink);
                    }
                    params.set('repo', repo);
                    return `deps.html?${params.toString()}`;
                };
                
                // Show ALL packages with repository usage
                html += `
                    <div class="mb-3">
                        <h6><i class="fas fa-box me-2"></i>Packages & Repository Usage (${uniquePackageCount})</h6>
                        <div class="list-group max-h-400 overflow-y-auto">
                `;
                
                allPackages.forEach(pkg => {
                    const repos = packageRepositories[pkg] || [];
                    const repoCount = repos.length;
                    
                    html += `
                        <div class="list-group-item">
                            <div class="d-flex justify-content-between align-items-start">
                                <div class="flex-grow-1">
                                    <strong><a href="${createPackageLink(pkg)}" class="text-decoration-none" target="_blank">${escapeHtml(pkg)}</a></strong>
                                    ${repoCount > 0 ? `
                                        <br><small class="text-muted">
                                            <i class="fas fa-folder me-1"></i>
                                            Used in <strong>${repoCount}</strong> repositor${repoCount !== 1 ? 'ies' : 'y'}
                                        </small>
                                    ` : '<br><small class="text-muted">Repository usage data not available</small>'}
                                </div>
                                ${repoCount > 0 ? `<span class="badge bg-secondary ms-2">${repoCount}</span>` : ''}
                            </div>
                            ${repoCount > 0 && repoCount <= 10 ? `
                                <div class="mt-2">
                                    <small class="text-muted">
                                        <i class="fas fa-code-branch me-1"></i>
                                        ${repos.map(r => `<a href="${createRepoLink(r)}" class="text-decoration-none" target="_blank"><code>${escapeHtml(r)}</code></a>`).join(', ')}
                                    </small>
                                </div>
                            ` : repoCount > 10 ? `
                                <div class="mt-2">
                                    <small class="text-muted">
                                        <i class="fas fa-code-branch me-1"></i>
                                        ${repos.slice(0, 5).map(r => `<a href="${createRepoLink(r)}" class="text-decoration-none" target="_blank"><code>${escapeHtml(r)}</code></a>`).join(', ')}
                                        <strong>+ ${repoCount - 5} more</strong>
                                    </small>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                // Risk Assessment - Focus on repository usage (single point of failure risk)
                if (repositoryCount >= 5) {
                    html += `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            <strong>High Single Point of Failure Risk:</strong> This contributor's packages are used across <strong>${repositoryCount} repositories</strong> (${uniquePackageCount} unique package${uniquePackageCount !== 1 ? 's' : ''}).
                            <br><br>
                            <strong>Risk:</strong> If this maintainer becomes unavailable, inactive, or compromised, ${repositoryCount} of your projects could be affected.
                            <br><br>
                            <strong>Recommendations:</strong>
                            <ul class="mb-0">
                                <li>Monitor this maintainer's activity and repository health</li>
                                <li>Consider identifying backup or alternative packages</li>
                                <li>Contribute to their projects to support sustainability</li>
                                <li>Document dependencies and mitigation plans</li>
                            </ul>
                        </div>
                    `;
                } else if (repositoryCount >= 3) {
                    html += `
                        <div class="alert alert-warning">
                            <i class="fas fa-info-circle me-2"></i>
                            <strong>Moderate Single Point of Failure Risk:</strong> This contributor's packages are used across <strong>${repositoryCount} repositories</strong> (${uniquePackageCount} unique package${uniquePackageCount !== 1 ? 's' : ''}).
                            <br><br>
                            Consider monitoring their activity and having contingency plans.
                        </div>
                    `;
                } else if (uniquePackageCount >= 5) {
                    html += `
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle me-2"></i>
                            <strong>Package Diversity:</strong> This contributor maintains ${uniquePackageCount} unique packages in your project.
                        </div>
                    `;
                }
                
                document.getElementById('authorDetailsContent').innerHTML = html;
                modal.show();
            }

            function displayAuthors(authors, ecosystemFilter, locationFilter) {
                const container = document.getElementById('authorContent');
                
                console.log(`üé® Authors Page - Displaying authors. Total: ${authors ? authors.length : 0}, Filter: ${ecosystemFilter}, Location: ${locationFilter}`);
                
                if (!authors || authors.length === 0) {
                    console.log('‚ö†Ô∏è Authors Page - No authors to display');
                    container.innerHTML = '<p class="text-muted text-center">No author data available. Run an analysis to generate author information.</p>';
                    return;
                }
                
                // Filter by ecosystem
                let filtered = authors;
                if (ecosystemFilter !== 'all') {
                    filtered = authors.filter(a => a.ecosystem === ecosystemFilter);
                    console.log(`üé® Authors Page - After filtering by ${ecosystemFilter}: ${filtered.length} authors`);
                }
                
                // Filter by location
                if (locationFilter !== 'all') {
                    filtered = filtered.filter(a => {
                        const location = a.metadata?.location || a.metadata?.company || null;
                        return location === locationFilter;
                    });
                    console.log(`üé® Authors Page - After filtering by location ${locationFilter}: ${filtered.length} authors`);
                }
                
                // Filter by funding if checkbox is checked
                const fundingFilterCheckbox = document.getElementById('fundingFilter');
                if (fundingFilterCheckbox && fundingFilterCheckbox.checked) {
                    filtered = filtered.filter(a => a.funding && (a.funding.github || a.funding.opencollective || a.funding.patreon || a.funding.tidelift || a.funding.url));
                    console.log(`üé® Authors Page - After filtering by funding: ${filtered.length} authors`);
                }
                
                // Filter by sanctioned countries if checkbox is checked
                const sanctionsFilterCheckbox = document.getElementById('sanctionsFilter');
                const sanctionsFilterActive = sanctionsFilterCheckbox && sanctionsFilterCheckbox.checked;
                if (sanctionsFilterActive && sanctionsService) {
                    filtered = filtered.filter(a => {
                        // Check all country codes (handles multiple locations)
                        const countryCodesToCheck = a.metadata?.countryCodes || (a.metadata?.countryCode ? [a.metadata.countryCode] : []);
                        if (countryCodesToCheck.length === 0) return false;
                        
                        // Author is sanctioned if ANY of their countries is sanctioned
                        return countryCodesToCheck.some(code => {
                            const sanctionCheck = sanctionsService.checkSanctioned(code);
                            return sanctionCheck.isSanctioned;
                        });
                    });
                    console.log(`üé® Authors Page - After filtering by sanctioned countries: ${filtered.length} authors`);
                }
                
                // Helper function to detect bot accounts
                function isBotAccount(author) {
                    // Check for [bot] suffix in username
                    if (author.author && /\[bot\]$/i.test(author.author)) {
                        return true;
                    }
                    // Check metadata type
                    if (author.metadata?.type === 'Bot' || author.metadata?.type === 'bot') {
                        return true;
                    }
                    // Check GitHub type
                    if (author.metadata?.github_type === 'Bot') {
                        return true;
                    }
                    // Check common bot patterns
                    const botPatterns = ['dependabot', 'renovate', 'snyk-bot', 'greenkeeper', 'codecov', 'coveralls', 'allcontributors'];
                    const authorLower = (author.author || '').toLowerCase();
                    return botPatterns.some(pattern => authorLower.includes(pattern));
                }
                
                // Separate into: human authors, organizations, and bots
                const botAuthors = filtered.filter(isBotAccount);
                const organizationAuthors = filtered.filter(a => !isBotAccount(a) && isOrganization(a));
                const humanAuthors = filtered.filter(a => !isBotAccount(a) && !isOrganization(a));
                
                // Store all filtered authors (after separation) for map display
                // Include human authors, organizations, and bots for map
                allFilteredAuthors = [...humanAuthors, ...organizationAuthors, ...botAuthors];
                
                // Update location filter dropdown with unique locations
                updateLocationFilter(filtered);
                
                if (filtered.length === 0) {
                    console.log('‚ö†Ô∏è Authors Page - No authors after filtering');
                    const fundingFilterCheckbox = document.getElementById('fundingFilter');
                    const fundingFilterActive = fundingFilterCheckbox && fundingFilterCheckbox.checked;
                    let message = 'No authors found';
                    if (ecosystemFilter !== 'all' && fundingFilterActive && sanctionsFilterActive) {
                        message = `No authors found for ecosystem "${ecosystemFilter}" with funding from sanctioned countries. Try adjusting filters.`;
                    } else if (ecosystemFilter !== 'all' && sanctionsFilterActive) {
                        message = `No authors found for ecosystem "${ecosystemFilter}" from sanctioned countries. Try selecting "All Ecosystems".`;
                    } else if (fundingFilterActive && sanctionsFilterActive) {
                        message = 'No authors found with funding information from sanctioned countries.';
                    } else if (sanctionsFilterActive) {
                        message = 'No authors found from sanctioned countries.';
                    } else if (ecosystemFilter !== 'all' && fundingFilterActive) {
                        message = `No authors found for ecosystem "${ecosystemFilter}" with funding. Try selecting "All Ecosystems" or removing the funding filter.`;
                    } else if (ecosystemFilter !== 'all') {
                        message = `No authors found for ecosystem "${ecosystemFilter}". Try selecting "All Ecosystems".`;
                    } else if (fundingFilterActive) {
                        message = 'No authors found with funding information.';
                    }
                    container.innerHTML = `<p class="text-muted text-center">${escapeHtml(message)}</p>`;
                    return;
                }
                
                // When sanctions filter is active, show ALL human authors (including single-package-single-repo)
                // Otherwise, separate human authors as before
                let allVisibleHumanAuthors;
                let singlePackageSingleRepo;
                
                if (sanctionsFilterActive) {
                    // Show all human authors when filtering by sanctions (compliance risk)
                    allVisibleHumanAuthors = humanAuthors;
                    singlePackageSingleRepo = [];
                } else {
                // Separate human authors:
                // 1. Multi-package authors (2+ packages) -> Always show in main table
                // 2. Single-package authors with multiple repos (1 package, 2+ repos) -> Show in main table (risk)
                // 3. Single-package authors with single repo (1 package, 1 repo) -> Hide behind section (low risk)
                const multiPackageAuthors = humanAuthors.filter(a => {
                    const uniquePackages = [...new Set(a.packages || [])];
                    return uniquePackages.length > 1;
                });
                
                const singlePackageMultipleRepos = humanAuthors.filter(a => {
                    const uniquePackages = [...new Set(a.packages || [])];
                    const repoCount = a.repositoryCount || 0;
                    return uniquePackages.length === 1 && repoCount > 1;
                });
                
                    singlePackageSingleRepo = humanAuthors.filter(a => {
                    const uniquePackages = [...new Set(a.packages || [])];
                    const repoCount = a.repositoryCount || 0;
                    return uniquePackages.length === 1 && repoCount === 1;
                });
                
                // Combine multi-package and single-package-multiple-repos for main display
                    allVisibleHumanAuthors = [...multiPackageAuthors, ...singlePackageMultipleRepos];
                }
                
                // Sort visible human authors by repository count (risk factor), then package count
                allVisibleHumanAuthors.sort((a, b) => {
                    const aRepoCount = a.repositoryCount || 0;
                    const bRepoCount = b.repositoryCount || 0;
                    if (bRepoCount !== aRepoCount) {
                        return bRepoCount - aRepoCount;
                    }
                    const aPkgCount = [...new Set(a.packages || [])].length;
                    const bPkgCount = [...new Set(b.packages || [])].length;
                    if (bPkgCount !== aPkgCount) {
                        return bPkgCount - aPkgCount;
                    }
                    return (b.count || 0) - (a.count || 0);
                });
                
                // Sort organizations by repository count, then package count
                organizationAuthors.sort((a, b) => {
                    const aRepoCount = a.repositoryCount || 0;
                    const bRepoCount = b.repositoryCount || 0;
                    if (bRepoCount !== aRepoCount) {
                        return bRepoCount - aRepoCount;
                    }
                    const aPkgCount = [...new Set(a.packages || [])].length;
                    const bPkgCount = [...new Set(b.packages || [])].length;
                    if (bPkgCount !== aPkgCount) {
                        return bPkgCount - aPkgCount;
                    }
                    return (b.count || 0) - (a.count || 0);
                });
                
                // Store filtered human authors
                filteredAuthors = allVisibleHumanAuthors;
                
                // Apply display limit
                const visibleAuthors = displayLimit === 'all' 
                    ? allVisibleHumanAuthors 
                    : allVisibleHumanAuthors.slice(0, 25);
                
                // Sort single-package-single-repo authors by occurrence count (descending)
                singlePackageSingleRepo.sort((a, b) => {
                    return (b.count || 0) - (a.count || 0);
                });
                
                // Store for event handlers (store all visible, not just current page)
                currentAuthors = allVisibleHumanAuthors;
                window.currentSinglePackageAuthors = singlePackageSingleRepo; // Store globally for toggle (low-risk authors)
                window.currentOrganizations = organizationAuthors; // Store organizations globally
                
                if (sanctionsFilterActive) {
                    console.log(`üé® Authors Page - Sanctions filter active: Showing ${visibleAuthors.length} of ${allVisibleHumanAuthors.length} human authors from sanctioned countries, ${organizationAuthors.length} organizations, ${botAuthors.length} bots`);
                } else {
                    const multiPackageCount = humanAuthors.filter(a => {
                        const uniquePackages = [...new Set(a.packages || [])];
                        return uniquePackages.length > 1;
                    }).length;
                    const singlePackageMultiRepoCount = humanAuthors.filter(a => {
                        const uniquePackages = [...new Set(a.packages || [])];
                        const repoCount = a.repositoryCount || 0;
                        return uniquePackages.length === 1 && repoCount > 1;
                    }).length;
                    console.log(`üé® Authors Page - Human Authors: ${allVisibleHumanAuthors.length} (${multiPackageCount} multi-package + ${singlePackageMultiRepoCount} single-package-multi-repo), Organizations: ${organizationAuthors.length}, Bots: ${botAuthors.length}, Hidden: ${singlePackageSingleRepo.length} (single-package-single-repo), Displaying: ${visibleAuthors.length} (limit: ${displayLimit})`);
                }
                
                let html = `
                    <div class="alert ${sanctionsFilterActive ? 'alert-danger' : 'alert-info'}">
                        <i class="fas ${sanctionsFilterActive ? 'fa-ban' : 'fa-info-circle'} me-2"></i>
                        ${sanctionsFilterActive ? '<strong>‚ö†Ô∏è Sanctioned Countries Filter Active:</strong> ' : ''}
                        Showing <strong>${visibleAuthors.length}</strong>${visibleAuthors.length < allVisibleHumanAuthors.length ? ` of <strong>${allVisibleHumanAuthors.length}</strong>` : ''} human author${allVisibleHumanAuthors.length !== 1 ? 's' : ''} from <strong>${new Set(allVisibleHumanAuthors.map(a => a.ecosystem)).size}</strong> ecosystem${new Set(allVisibleHumanAuthors.map(a => a.ecosystem)).size !== 1 ? 's' : ''}
                        ${sanctionsFilterActive ? 'from sanctioned countries' : ''}
                        ${!sanctionsFilterActive && allVisibleHumanAuthors.length > 0 ? `(${humanAuthors.filter(a => {
                            const uniquePackages = [...new Set(a.packages || [])];
                            return uniquePackages.length > 1;
                        }).length} with multiple packages, ${humanAuthors.filter(a => {
                            const uniquePackages = [...new Set(a.packages || [])];
                            const repoCount = a.repositoryCount || 0;
                            return uniquePackages.length === 1 && repoCount > 1;
                        }).length} with single package across multiple repos)` : ''}
                        ${visibleAuthors.length < allVisibleHumanAuthors.length ? `
                            <br><a href="#" class="btn btn-sm btn-primary mt-2" id="showAllAuthorsBtn">
                                <i class="fas fa-list me-1"></i>Show All ${allVisibleHumanAuthors.length} Authors
                            </a>
                        ` : ''}
                    </div>
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Author</th>
                                    <th>Ecosystem</th>
                                    <th>Packages</th>
                                    <th>Repository Usage</th>
                                    <th>Location</th>
                                    <th class="text-center">Social</th>
                                    <th class="text-center">Sponsorship</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                visibleAuthors.forEach((author, index) => {
                    // Find the actual index in allVisibleHumanAuthors for the data-author-index attribute
                    const actualIndex = allVisibleHumanAuthors.indexOf(author);
                    
                    const uniquePackages = [...new Set(author.packages)];
                    const uniquePackageCount = uniquePackages.length;
                    const repositoryCount = author.repositoryCount || 0;
                    const samplePackages = uniquePackages.slice(0, 3).join(', ');
                    
                    // Build location cell
                    const location = author.metadata?.location || author.metadata?.company || null;
                    const countryCode = author.metadata?.countryCode || null;
                    let locationCell = location 
                        ? `<td><i class="fas fa-map-marker-alt me-1 text-muted"></i><small>${escapeHtml(location)}</small>`
                        : '<td class="text-muted">‚Äî';
                    // Add tentative correlation badge if present
                    if (author.metadata?.tentative_correlation) {
                        locationCell += ` <span class="badge bg-warning text-dark ms-1" title="Tentative correlation - same GitHub user ID">‚ö†Ô∏è</span>`;
                    }
                    // Check for sanctioned countries (check all country codes if multiple)
                    const countryCodesToCheck = author.metadata?.countryCodes || (author.metadata?.countryCode ? [author.metadata.countryCode] : []);
                    if (countryCodesToCheck.length > 0 && sanctionsService) {
                        const sanctionedCountries = [];
                        countryCodesToCheck.forEach(code => {
                            const sanctionCheck = sanctionsService.checkSanctioned(code);
                            if (sanctionCheck.isSanctioned) {
                                const sources = sanctionCheck.sources.join(', ');
                                sanctionedCountries.push({ code, sources });
                            }
                        });
                        if (sanctionedCountries.length > 0) {
                            const allSources = [...new Set(sanctionedCountries.flatMap(s => s.sources.split(', ')))].join(', ');
                            const codes = sanctionedCountries.map(s => s.code).join(', ');
                            locationCell += ` <span class="badge bg-danger ms-1" title="Sanctioned country (${allSources}): ${escapeHtml(codes)}">üö´ ${allSources}</span>`;
                        }
                    }
                    locationCell += '</td>';
                    
                    // Build social profile icons cell
                    const socialIcons = getSocialProfileIcons(author);
                    let socialCell = '<td class="text-center">‚Äî</td>';
                    if (socialIcons.length > 0) {
                        const iconLinks = socialIcons.map(icon => 
                            `<a href="${icon.url}" target="_blank" rel="noreferrer noopener" title="${icon.title}" class="text-decoration-none ${icon.color} me-2"><i class="${icon.icon}"></i></a>`
                        ).join('');
                        socialCell = `<td class="text-center">${iconLinks}</td>`;
                    }
                    
                    // Build sponsorship cell
                    let sponsorshipCell = '<td class="text-center">‚Äî</td>';
                    if (author.funding) {
                        const platforms = [];
                        if (author.funding.github) {
                            const githubSponsorUsername = normalizeGitHubUsername(author.metadata?.github || author.author);
                            platforms.push('<a href="' + (author.funding.url || `https://github.com/sponsors/${encodeURIComponent(githubSponsorUsername)}`) + '" target="_blank" title="GitHub Sponsors"><i class="fab fa-github text-dark"></i></a>');
                        }
                        if (author.funding.opencollective) {
                            // Securely extract Open Collective username from URL
                            let ocUsername = author.author;
                            if (author.funding.url && isUrlFromHostname(author.funding.url, 'opencollective.com')) {
                                try {
                                    const url = new URL(author.funding.url.startsWith('http') ? author.funding.url : 'https://' + author.funding.url);
                                    const pathParts = url.pathname.split('/').filter(p => p);
                                    if (pathParts.length > 0) {
                                        ocUsername = pathParts[0];
                                    }
                                } catch (e) {
                                    // If URL parsing fails, use author name as fallback
                                    ocUsername = author.author;
                                }
                            }
                            platforms.push('<a href="https://opencollective.com/' + encodeURIComponent(ocUsername) + '" target="_blank" title="Open Collective"><i class="fas fa-hand-holding-usd text-primary"></i></a>');
                        }
                        if (author.funding.patreon) platforms.push('<a href="' + (author.funding.url || `https://patreon.com/${encodeURIComponent(author.author)}`) + '" target="_blank" title="Patreon"><i class="fab fa-patreon text-danger"></i></a>');
                        if (author.funding.tidelift) platforms.push('<a href="' + author.funding.url + '" target="_blank" title="Tidelift"><i class="fas fa-gift text-warning"></i></a>');
                        
                        if (platforms.length > 0) {
                            sponsorshipCell = '<td class="text-center"><span class="d-flex justify-content-center gap-2">' + platforms.join(' ') + '</span></td>';
                        } else if (author.funding.url) {
                            sponsorshipCell = '<td class="text-center"><a href="' + author.funding.url + '" target="_blank" title="Funding available"><i class="fas fa-donate text-success"></i></a></td>';
                        }
                    }
                    
                    // Risk indicator: High repository usage = single point of failure
                    let riskBadge = '';
                    if (repositoryCount >= 5) {
                        riskBadge = ' <span class="badge bg-danger ms-1" title="High risk: Single point of failure across multiple projects">High Risk</span>';
                    } else if (repositoryCount >= 3) {
                        riskBadge = ' <span class="badge bg-warning text-dark ms-1" title="Moderate risk: Used across multiple projects">Moderate Risk</span>';
                    }
                    
                    html += `
                        <tr>
                            <td>${index + 1}</td>
                            <td>
                                <a href="#" class="text-decoration-none author-details-link" data-author-index="${actualIndex}">
                                    <strong><i class="fas fa-user me-1"></i>${author.author}</strong>
                                </a>
                            </td>
                            <td><span class="badge bg-info">${author.ecosystem}</span></td>
                            <td>
                                <a href="#" class="text-decoration-none packages-link" data-author-index="${actualIndex}">
                                    ${uniquePackageCount === 1 
                                        ? `<span class="badge bg-primary">${escapeHtml(uniquePackages[0])}</span>`
                                        : `<span class="badge bg-primary">${uniquePackageCount}</span>`}
                                </a>
                            </td>
                            <td>
                                <span class="badge bg-secondary">${repositoryCount} repo${repositoryCount !== 1 ? 's' : ''}</span>
                                ${riskBadge}
                            </td>
                            ${locationCell}
                            ${socialCell}
                            ${sponsorshipCell}
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Add single-package-single-repo authors section (before organizations and bots)
                if (singlePackageSingleRepo.length > 0) {
                    let singlePackageHtml = `
                        <div class="alert alert-secondary mt-3 cursor-pointer" id="singlePackageAuthorsToggle">
                            <i class="fas fa-info-circle me-2"></i>
                            <strong>${singlePackageSingleRepo.length}</strong> additional author${singlePackageSingleRepo.length !== 1 ? 's' : ''} 
                            with one package used in one repository ${ecosystemFilter !== 'all' ? 'in this ecosystem ' : ''}
                            <span class="text-decoration-underline ms-2">
                                <i class="fas fa-chevron-down" id="singlePackageAuthorsToggleIcon"></i>
                                <span id="singlePackageAuthorsToggleText">Click to show</span>
                            </span>
                        </div>
                        <div id="singlePackageAuthorsList" class="mt-3 d-none">
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                These authors maintain only one package used in a single repository (lower risk - isolated impact).
                            </div>
                            <div class="table-responsive">
                                <table class="table table-hover table-sm">
                                    <thead>
                                        <tr>
                                            <th>#</th>
                                            <th>Author</th>
                                            <th>Ecosystem</th>
                                            <th>Package</th>
                                            <th>Repository</th>
                                            <th>Location</th>
                                            <th class="text-center">Social</th>
                                            <th class="text-center">Sponsorship</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    
                    singlePackageSingleRepo.forEach((author, index) => {
                        const packageName = author.packages[0] || 'N/A';
                        const repositories = author.repositories || [];
                        const repoName = repositories.length > 0 ? repositories[0] : 'N/A';
                        
                        // Build location cell
                        const location = author.metadata?.location || author.metadata?.company || null;
                        const locationCell = location 
                            ? `<td><i class="fas fa-map-marker-alt me-1 text-muted"></i><small>${escapeHtml(location)}</small></td>`
                            : '<td class="text-muted">‚Äî</td>';
                        
                        // Build social profile icons cell
                        const socialIcons = getSocialProfileIcons(author);
                        let socialCell = '<td class="text-center">‚Äî</td>';
                        if (socialIcons.length > 0) {
                            const iconLinks = socialIcons.map(icon => 
                                `<a href="${icon.url}" target="_blank" rel="noreferrer noopener" title="${icon.title}" class="text-decoration-none ${icon.color} me-2"><i class="${icon.icon}"></i></a>`
                            ).join('');
                            socialCell = `<td class="text-center">${iconLinks}</td>`;
                        }
                        
                        // Build sponsorship cell
                        let sponsorshipCell = '<td class="text-center">‚Äî</td>';
                        if (author.funding) {
                            const platforms = [];
                            if (author.funding.github) {
                                const githubSponsorUsername = normalizeGitHubUsername(author.metadata?.github || author.author);
                                platforms.push('<a href="' + (author.funding.url || `https://github.com/sponsors/${encodeURIComponent(githubSponsorUsername)}`) + '" target="_blank" title="GitHub Sponsors"><i class="fab fa-github text-dark"></i></a>');
                            }
                            if (author.funding.opencollective) {
                                // Securely extract Open Collective username from URL
                                let ocUsername = author.author;
                                if (author.funding.url && isUrlFromHostname(author.funding.url, 'opencollective.com')) {
                                    try {
                                        const url = new URL(author.funding.url.startsWith('http') ? author.funding.url : 'https://' + author.funding.url);
                                        const pathParts = url.pathname.split('/').filter(p => p);
                                        if (pathParts.length > 0) {
                                            ocUsername = pathParts[0];
                                        }
                                    } catch (e) {
                                        // If URL parsing fails, use author name as fallback
                                        ocUsername = author.author;
                                    }
                                }
                                platforms.push('<a href="https://opencollective.com/' + encodeURIComponent(ocUsername) + '" target="_blank" title="Open Collective"><i class="fas fa-hand-holding-usd text-primary"></i></a>');
                            }
                            if (author.funding.patreon) platforms.push('<a href="' + (author.funding.url || `https://patreon.com/${encodeURIComponent(author.author)}`) + '" target="_blank" title="Patreon"><i class="fab fa-patreon text-danger"></i></a>');
                            if (author.funding.tidelift) platforms.push('<a href="' + author.funding.url + '" target="_blank" title="Tidelift"><i class="fas fa-gift text-warning"></i></a>');
                            
                            if (platforms.length > 0) {
                                sponsorshipCell = '<td class="text-center"><span class="d-flex justify-content-center gap-2">' + platforms.join(' ') + '</span></td>';
                            } else if (author.funding.url) {
                                sponsorshipCell = '<td class="text-center"><a href="' + author.funding.url + '" target="_blank" title="Funding available"><i class="fas fa-donate text-success"></i></a></td>';
                            }
                        }
                        
                        singlePackageHtml += `
                            <tr>
                                <td>${index + 1}</td>
                                <td>
                                    <a href="#" class="text-decoration-none single-author-details-link" data-author-index="${index}">
                                        <i class="fas fa-user me-1"></i>${escapeHtml(author.author)}
                                    </a>
                                </td>
                                <td><span class="badge bg-info">${escapeHtml(author.ecosystem)}</span></td>
                                <td><code>${escapeHtml(packageName)}</code></td>
                                <td><code>${escapeHtml(repoName)}</code></td>
                                ${locationCell}
                                ${socialCell}
                                ${sponsorshipCell}
                            </tr>
                        `;
                    });
                    
                    singlePackageHtml += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                    
                    // Append to container instead of html variable
                    container.insertAdjacentHTML('beforeend', singlePackageHtml);
                }
                
                // Add organizations table (collapsible section, after single-package authors)
                if (organizationAuthors.length > 0) {
                    // Sort organizations by repository count
                    organizationAuthors.sort((a, b) => {
                        const aRepoCount = a.repositoryCount || 0;
                        const bRepoCount = b.repositoryCount || 0;
                        if (bRepoCount !== aRepoCount) {
                            return bRepoCount - aRepoCount;
                        }
                        const aPkgCount = [...new Set(a.packages || [])].length;
                        const bPkgCount = [...new Set(b.packages || [])].length;
                        return bPkgCount - aPkgCount;
                    });
                    
                    let orgHtml = `
                        <div class="card mt-4">
                            <div class="card-header bg-info text-white d-flex justify-content-between align-items-center cursor-pointer" id="organizationsToggle">
                                <h5 class="mb-0"><i class="fas fa-building me-2"></i>Organizations (${organizationAuthors.length})</h5>
                                <i class="fas fa-chevron-up" id="organizationsToggleIcon"></i>
                            </div>
                            <div class="card-body" id="organizationsList">
                                <div class="alert alert-info">
                                    <i class="fas fa-info-circle me-2"></i>
                                    These are organizations (e.g., GitHub organizations, PyPI organizations) that maintain packages or workflows in your environments.
                                </div>
                                <div class="table-responsive">
                                    <table class="table table-hover table-sm">
                                        <thead>
                                            <tr>
                                                <th>#</th>
                                                <th>Organization</th>
                                                <th>Ecosystem</th>
                                                <th>Packages</th>
                                                <th>Repository Usage</th>
                                                <th class="text-center">Social</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                    `;
                    
                    organizationAuthors.forEach((org, index) => {
                        const uniquePackages = [...new Set(org.packages || [])];
                        const uniquePackageCount = uniquePackages.length;
                        const repositoryCount = org.repositoryCount || 0;
                        const samplePackages = uniquePackages.slice(0, 3).join(', ');
                        
                        // Build social profile icons cell
                        const socialIcons = [];
                        if (org.metadata?.github) {
                            const githubUsername = normalizeGitHubUsername(org.metadata.github);
                            if (githubUsername && githubUsername.trim()) {
                                socialIcons.push({
                                    url: `https://github.com/${encodeURIComponent(githubUsername)}`,
                                    icon: 'fab fa-github',
                                    title: 'GitHub Organization',
                                    color: 'text-dark'
                                });
                            }
                        }
                        if (org.ecosystem === 'pypi' && org.metadata?.pypi_organization) {
                            socialIcons.push({
                                url: `https://pypi.org/org/${encodeURIComponent(org.metadata.pypi_organization)}/`,
                                icon: 'fas fa-cube',
                                title: 'PyPI Organization',
                                color: 'text-primary'
                            });
                        }
                        
                        let socialCell = '<td class="text-center">‚Äî</td>';
                        if (socialIcons.length > 0) {
                            const iconLinks = socialIcons.map(icon => 
                                `<a href="${icon.url}" target="_blank" rel="noreferrer noopener" title="${icon.title}" class="text-decoration-none ${icon.color} me-2"><i class="${icon.icon}"></i></a>`
                            ).join('');
                            socialCell = `<td class="text-center">${iconLinks}</td>`;
                        }
                        
                        orgHtml += `
                            <tr>
                                <td>${index + 1}</td>
                                <td>
                                    <strong><i class="fas fa-building me-1"></i>${escapeHtml(org.author)}</strong>
                                </td>
                                <td><span class="badge bg-info">${org.ecosystem}</span></td>
                                <td>
                                    ${uniquePackageCount === 1 
                                        ? `<span class="badge bg-primary">${escapeHtml(uniquePackages[0])}</span>`
                                        : `<span class="badge bg-primary" title="${escapeHtml(samplePackages)}">${uniquePackageCount}</span>`}
                                </td>
                                <td>
                                    <span class="badge bg-secondary">${repositoryCount} repo${repositoryCount !== 1 ? 's' : ''}</span>
                                </td>
                                ${socialCell}
                            </tr>
                        `;
                    });
                    
                    orgHtml += `
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    container.innerHTML += orgHtml;
                }
                
                // Add bot accounts table (collapsible section, after organizations)
                if (botAuthors.length > 0) {
                    // Sort bots by repository count
                    botAuthors.sort((a, b) => {
                        const aRepoCount = a.repositoryCount || 0;
                        const bRepoCount = b.repositoryCount || 0;
                        if (bRepoCount !== aRepoCount) {
                            return bRepoCount - aRepoCount;
                        }
                        const aPkgCount = [...new Set(a.packages || [])].length;
                        const bPkgCount = [...new Set(b.packages || [])].length;
                        return bPkgCount - aPkgCount;
                    });
                    
                    let botHtml = `
                        <div class="card mt-4">
                            <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center cursor-pointer" id="botsToggle">
                                <h5 class="mb-0"><i class="fas fa-robot me-2"></i>Active Bots in the Environments (${botAuthors.length})</h5>
                                <i class="fas fa-chevron-up" id="botsToggleIcon"></i>
                            </div>
                            <div class="card-body" id="botsList">
                                <div class="alert alert-info">
                                    <i class="fas fa-info-circle me-2"></i>
                                    These are automated bot accounts (e.g., Dependabot, Renovate) that maintain packages or workflows in your environments.
                                </div>
                                <div class="table-responsive">
                                    <table class="table table-hover table-sm">
                                        <thead>
                                            <tr>
                                                <th>#</th>
                                                <th>Bot Name</th>
                                                <th>Ecosystem</th>
                                                <th>Packages</th>
                                                <th>Repository Usage</th>
                                                <th>Type</th>
                                                <th class="text-center">Social</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                    `;
                    
                    botAuthors.forEach((bot, index) => {
                        const uniquePackages = [...new Set(bot.packages || [])];
                        const uniquePackageCount = uniquePackages.length;
                        const repositoryCount = bot.repositoryCount || 0;
                        const samplePackages = uniquePackages.slice(0, 3).join(', ');
                        
                        // Determine bot type
                        let botType = 'Unknown';
                        const botName = (bot.author || '').toLowerCase();
                        if (botName.includes('dependabot')) {
                            botType = 'Dependabot';
                        } else if (botName.includes('renovate')) {
                            botType = 'Renovate';
                        } else if (botName.includes('snyk')) {
                            botType = 'Snyk';
                        } else if (bot.metadata?.type === 'Bot') {
                            botType = 'GitHub Bot';
                        } else if (/\[bot\]$/i.test(bot.author)) {
                            botType = 'GitHub Bot';
                        }
                        
                        // Build social profile icons cell
                        const socialIcons = getSocialProfileIcons(bot);
                        let socialCell = '<td class="text-center">‚Äî</td>';
                        if (socialIcons.length > 0) {
                            const iconLinks = socialIcons.map(icon => 
                                `<a href="${icon.url}" target="_blank" rel="noreferrer noopener" title="${icon.title}" class="text-decoration-none ${icon.color} me-2"><i class="${icon.icon}"></i></a>`
                            ).join('');
                            socialCell = `<td class="text-center">${iconLinks}</td>`;
                        }
                        
                        botHtml += `
                            <tr>
                                <td>${index + 1}</td>
                                <td>
                                    <strong><i class="fas fa-robot me-1"></i>${escapeHtml(bot.author)}</strong>
                                </td>
                                <td><span class="badge bg-info">${bot.ecosystem}</span></td>
                                <td>
                                    ${uniquePackageCount === 1 
                                        ? `<span class="badge bg-primary">${escapeHtml(uniquePackages[0])}</span>`
                                        : `<span class="badge bg-primary" title="${escapeHtml(samplePackages)}">${uniquePackageCount}</span>`}
                                </td>
                                <td>
                                    <span class="badge bg-secondary">${repositoryCount} repo${repositoryCount !== 1 ? 's' : ''}</span>
                                </td>
                                <td><span class="badge bg-dark">${botType}</span></td>
                                ${socialCell}
                            </tr>
                        `;
                    });
                    
                    botHtml += `
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    container.innerHTML += botHtml;
                }
                
                // Attach event listeners
                attachEventListeners();
                
                // Update map if visible - use allFilteredAuthors to include ALL authors (including single-package-single-repo)
                if (authorMapCard && authorMapCard.style.display !== 'none' && authorMap) {
                    displayAuthorMap(allFilteredAuthors).catch(err => 
                        console.warn('Failed to update author map:', err)
                    );
                    // Invalidate map size to ensure it renders correctly after content changes
                    setTimeout(() => {
                        if (authorMap) {
                            authorMap.invalidateSize();
                        }
                    }, 100);
                }
            }
            
            function attachEventListeners() {
                // "Show All Authors" button in alert
                const showAllAuthorsBtn = document.getElementById('showAllAuthorsBtn');
                if (showAllAuthorsBtn) {
                    showAllAuthorsBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        // Trigger the "Show All" radio button
                        const displayLimitAll = document.getElementById('displayLimitAll');
                        if (displayLimitAll) {
                            displayLimitAll.checked = true;
                            displayLimit = 'all';
                            localStorage.setItem('authorsDisplayLimit', 'all');
                            loadAuthorData();
                            // Scroll to top to show the toggle selection
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        }
                    });
                }
                
                // Author details links
                document.querySelectorAll('.author-details-link').forEach(link => {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const index = parseInt(this.getAttribute('data-author-index'));
                        const author = currentAuthors[index];
                        if (author) {
                            showAuthorDetailsModal(author);
                        }
                    });
                });
                
                // Packages column links (clickable)
                document.querySelectorAll('.packages-link').forEach(link => {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const index = parseInt(this.getAttribute('data-author-index'));
                        const author = currentAuthors[index];
                        if (author) {
                            showPackageModal(author);
                        }
                    });
                });
                
                // Single package authors toggle
                const toggleElement = document.getElementById('singlePackageAuthorsToggle');
                if (toggleElement) {
                    toggleElement.addEventListener('click', function(e) {
                        e.preventDefault();
                        const listElement = document.getElementById('singlePackageAuthorsList');
                        const iconElement = document.getElementById('singlePackageAuthorsToggleIcon');
                        const textElement = document.getElementById('singlePackageAuthorsToggleText');
                        
                        if (!listElement || !iconElement || !textElement) return;
                        
                        // Check if hidden using Bootstrap's d-none class
                        const isHidden = listElement.classList.contains('d-none');
                        
                        if (isHidden) {
                            // Show the list
                            listElement.classList.remove('d-none');
                            iconElement.classList.remove('fa-chevron-down');
                            iconElement.classList.add('fa-chevron-up');
                            textElement.textContent = 'Click to hide';
                        } else {
                            // Hide the list
                            listElement.classList.add('d-none');
                            iconElement.classList.remove('fa-chevron-up');
                            iconElement.classList.add('fa-chevron-down');
                            textElement.textContent = 'Click to show';
                        }
                    });
                }
                
                // Organizations toggle (collapsible)
                const organizationsToggle = document.getElementById('organizationsToggle');
                if (organizationsToggle) {
                    organizationsToggle.addEventListener('click', function(e) {
                        e.preventDefault();
                        const listElement = document.getElementById('organizationsList');
                        const iconElement = document.getElementById('organizationsToggleIcon');
                        
                        if (!listElement || !iconElement) return;
                        
                        // Check if hidden using Bootstrap's d-none class
                        const isHidden = listElement.classList.contains('d-none');
                        
                        if (isHidden) {
                            // Show the list
                            listElement.classList.remove('d-none');
                            iconElement.classList.remove('fa-chevron-down');
                            iconElement.classList.add('fa-chevron-up');
                        } else {
                            // Hide the list
                            listElement.classList.add('d-none');
                            iconElement.classList.remove('fa-chevron-up');
                            iconElement.classList.add('fa-chevron-down');
                        }
                    });
                }
                
                // Bots toggle (collapsible)
                const botsToggle = document.getElementById('botsToggle');
                if (botsToggle) {
                    botsToggle.addEventListener('click', function(e) {
                        e.preventDefault();
                        const listElement = document.getElementById('botsList');
                        const iconElement = document.getElementById('botsToggleIcon');
                        
                        if (!listElement || !iconElement) return;
                        
                        // Check if hidden using Bootstrap's d-none class
                        const isHidden = listElement.classList.contains('d-none');
                        
                        if (isHidden) {
                            // Show the list
                            listElement.classList.remove('d-none');
                            iconElement.classList.remove('fa-chevron-down');
                            iconElement.classList.add('fa-chevron-up');
                        } else {
                            // Hide the list
                            listElement.classList.add('d-none');
                            iconElement.classList.remove('fa-chevron-up');
                            iconElement.classList.add('fa-chevron-down');
                        }
                    });
                }
                
                // Single author details links
                document.querySelectorAll('.single-author-details-link').forEach(link => {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const index = parseInt(this.getAttribute('data-author-index'));
                        const author = window.currentSinglePackageAuthors?.[index];
                        if (author) {
                            showAuthorDetailsModal(author);
                        }
                    });
                });
            }
        });
    </script>

    <!-- Footer -->
    <footer class="bg-light mt-5 py-4">
        <div class="container">
            <div class="row">
                <!-- First Column: SBOM Play Tool -->
                <div class="col-md-4">
                    <h6 class="text-primary">SBOM Play</h6>
                    <p class="text-muted small mb-3">
                        A client-side tool for analyzing Software Bill of Materials from GitHub organizations and users.
                        All processing happens in your browser for maximum privacy and security.
                    </p>
                    <p class="text-muted small mb-0">
                        <strong>Privacy-First:</strong> All processing happens in your browser<br>
                        <strong>No Server Required:</strong> Works entirely client-side<br>
                        <strong>Persistent Storage:</strong> Results saved in browser storage<br>
                        <strong>Rate Limit Aware:</strong> Handles GitHub API limits intelligently
                    </p>
                </div>
                
                <!-- Second Column: Links -->
                <div class="col-md-4">
                    <h6 class="text-primary">Resources</h6>
                    <div class="d-flex flex-column gap-2">
                        <a href="https://cyfinoid.com/" target="_blank" class="btn btn-outline-primary btn-sm">
                            <i class="fas fa-globe me-1"></i>Website
                        </a>
                        <a href="https://cyfinoid.com/blog/" target="_blank" class="btn btn-outline-primary btn-sm">
                            <i class="fas fa-blog me-1"></i>Blog
                        </a>
                        <a href="https://cyfinoid.com/trainings/#upcoming-trainings" target="_blank" class="btn btn-outline-primary btn-sm">
                            <i class="fas fa-graduation-cap me-1"></i>Upcoming Trainings
                        </a>
                        <a href="https://cyfinoid.com/opensource-by-cyfinoid/" target="_blank" class="btn btn-outline-primary btn-sm">
                            <i class="fab fa-github me-1"></i>Open Source by Cyfinoid
                        </a>
                    </div>
                </div>
                
                <!-- Third Column: Company Information -->
                <div class="col-md-4">
                    <h6 class="text-primary">About Cyfinoid Research</h6>
                    <p class="text-muted small mb-3">
                        Leading cybersecurity research company specializing in software supply chain security, 
                        Android security, and cloud security. Our expertise spans across comprehensive software 
                        supply chain protection.
                    </p>
                </div>
            </div>
            <hr class="my-3">
            <div class="text-center">
                <small class="text-muted">
                    ¬© 2025 Cyfinoid Research. All rights reserved. | 
                    <a href="https://github.com/cyfinoid/sbomplay" target="_blank" class="text-muted">
                        <i class="fab fa-github me-1"></i>View on GitHub
                    </a>
                </small>
            </div>
        </div>
    </footer>
</body>
</html>

